import{_ as a,c as s,a2 as o,o as n}from"./chunks/framework.H8_ecXae.js";const u=JSON.parse('{"title":"Expressões Regulares","description":"","frontmatter":{},"headers":[],"relativePath":"chatbotbook/11_expressoes_regulares.md","filePath":"chatbotbook/11_expressoes_regulares.md"}'),r={name:"chatbotbook/11_expressoes_regulares.md"};function t(i,e,d,p,c,l){return n(),s("div",null,e[0]||(e[0]=[o(`<h1 id="expressoes-regulares" tabindex="-1">Expressões Regulares <a class="header-anchor" href="#expressoes-regulares" aria-label="Permalink to &quot;Expressões Regulares&quot;">​</a></h1><p>Expressões regulares, frequentemente abreviadas como regex, são sequências de caracteres que definem padrões de busca. Elas são utilizadas em chatbots para diversas tarefas relacionadas ao processamento e à análise de texto fornecido pelos usuários. Algumas das aplicações incluem:</p><ul><li><p><strong>Extração de entidades:</strong> Identificação e extração de informações específicas, como endereços de e-mail, números de telefone, datas e outros dados estruturados presentes na entrada do usuário.</p></li><li><p><strong>Validação de entradas do usuário:</strong> Verificação se a entrada do usuário corresponde a um formato esperado, como datas em um formato específico (DD/MM/AAAA), códigos postais ou outros padrões predefinidos.</p></li><li><p><strong>Detecção de Intenção:</strong> Detecção de comandos específicos inseridos pelo usuário, como <code>/ajuda</code>, <code>/iniciar</code> ou palavras-chave que indicam uma intenção específica.</p></li><li><p><strong>Limpeza de texto:</strong> Remoção de ruídos e elementos indesejados do texto, como tags HTML, espaços em branco excessivos ou caracteres especiais que podem interferir no processamento subsequente.</p></li><li><p><strong>Tokenização simples:</strong> Embora métodos mais avançados sejam comuns em PLN, regex pode ser usada para dividir o texto em unidades menores (tokens) com base em padrões simples.</p></li></ul><p>Essas tarefas são fundamentais para garantir que o chatbot possa interpretar e responder adequadamente às entradas dos usuários, especialmente em cenários onde a informação precisa ser estruturada ou verificada antes de ser processada por modelos de linguagem mais complexos.</p><h2 id="fundamentos-do-modulo-re-em-python" tabindex="-1">Fundamentos do Módulo <code>re</code> em Python <a class="header-anchor" href="#fundamentos-do-modulo-re-em-python" aria-label="Permalink to &quot;Fundamentos do Módulo \`re\` em Python&quot;">​</a></h2><p>O módulo <code>re</code> em Python é a biblioteca padrão para trabalhar com expressões regulares. Ele fornece diversas funções que permitem realizar operações de busca, correspondência e substituição em strings com base em padrões definidos por regex. Algumas das funções mais utilizadas incluem:</p><ul><li><p><code>re.match(pattern, string)</code>: Tenta encontrar uma correspondência do padrão no <em>início</em> da string. Se uma correspondência for encontrada, retorna um objeto de correspondência; caso contrário, retorna <code>None</code>.</p></li><li><p><code>re.search(pattern, string)</code>: Procura a primeira ocorrência do padrão em <em>qualquer posição</em> da string. Retorna um objeto de correspondência se encontrado, ou <code>None</code> caso contrário.</p></li><li><p><code>re.findall(pattern, string)</code>: Encontra <em>todas</em> as ocorrências não sobrepostas do padrão na string e as retorna como uma lista de strings.</p></li><li><p><code>re.sub(pattern, repl, string)</code>: Substitui todas as ocorrências do padrão na string pela string de substituição <code>repl</code>. Retorna a nova string resultante.</p></li></ul><h3 id="exemplo-basico-extracao-de-e-mails" tabindex="-1">Exemplo Básico: Extração de E-mails <a class="header-anchor" href="#exemplo-basico-extracao-de-e-mails" aria-label="Permalink to &quot;Exemplo Básico: Extração de E-mails&quot;">​</a></h3><p>Um caso de uso comum em chatbots é a extração de endereços de e-mail do texto fornecido pelo usuário. O seguinte exemplo em Python demonstra como usar <code>re.findall</code> para realizar essa tarefa:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import re</span></span>
<span class="line"><span></span></span>
<span class="line"><span>texto = &quot;Entre em contato em exemplo@email.com ou suporte@outroemail.com.&quot;</span></span>
<span class="line"><span>padrao = r&#39;\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b&#39;</span></span>
<span class="line"><span>emails = re.findall(padrao, texto)</span></span>
<span class="line"><span>print(emails)</span></span></code></pre></div><p>A saída deste código será:</p><pre><code>[&#39;exemplo@email.com&#39;, &#39;suporte@outroemail.com&#39;]
</code></pre><p>Este exemplo ilustra a eficácia das regex para identificar e extrair informações específicas de um texto.</p><h2 id="sintaxe-de-expressoes-regulares" tabindex="-1">Sintaxe de Expressões Regulares <a class="header-anchor" href="#sintaxe-de-expressoes-regulares" aria-label="Permalink to &quot;Sintaxe de Expressões Regulares&quot;">​</a></h2><p>A sintaxe das expressões regulares consiste em uma combinação de caracteres literais (que correspondem a si mesmos) e metacaracteres, que possuem significados especiais e permitem definir padrões de busca mais complexos. Alguns dos metacaracteres mais importantes incluem:</p><h2 id="casos-de-uso-especificos-em-chatbots" tabindex="-1">Casos de Uso Específicos em Chatbots <a class="header-anchor" href="#casos-de-uso-especificos-em-chatbots" aria-label="Permalink to &quot;Casos de Uso Específicos em Chatbots&quot;">​</a></h2><p>As expressões regulares podem ser aplicadas em uma variedade de cenários no desenvolvimento de chatbots. A seguir, apresentamos alguns casos de uso comuns com exemplos práticos em Python.</p><h3 id="validacao-de-datas" tabindex="-1">Validação de Datas <a class="header-anchor" href="#validacao-de-datas" aria-label="Permalink to &quot;Validação de Datas&quot;">​</a></h3><p>Chatbots que lidam com agendamentos ou reservas frequentemente precisam validar se a data fornecida pelo usuário está em um formato correto. O seguinte exemplo demonstra como validar datas no formato DD/MM/AAAA:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import re</span></span>
<span class="line"><span></span></span>
<span class="line"><span>padrao_data = r&#39;\\b\\d{2}/\\d{2}/\\d{4}\\b&#39;</span></span>
<span class="line"><span>datas_teste = [&quot;31/12/2020&quot;, &quot;1/1/2021&quot;, &quot;2023-05-10&quot;, &quot;25/06/2025 10:00&quot;]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>for data in datas_teste:</span></span>
<span class="line"><span>    if re.match(padrao_data, data):</span></span>
<span class="line"><span>        print(f&quot;&#39;{data}&#39; é uma data válida no formato DD/MM/AAAA.&quot;)</span></span>
<span class="line"><span>    else:</span></span>
<span class="line"><span>        print(f&quot;&#39;{data}&#39; não é uma data válida no formato DD/MM/AAAA.&quot;)</span></span></code></pre></div><p>A saída deste código ilustra quais das strings de teste correspondem ao padrão de data especificado.</p><h3 id="analise-de-comandos" tabindex="-1">Análise de Comandos <a class="header-anchor" href="#analise-de-comandos" aria-label="Permalink to &quot;Análise de Comandos&quot;">​</a></h3><p>Em interfaces de chatbot baseadas em texto, os usuários podem interagir através de comandos específicos, como <code>/ajuda</code> ou <code>/iniciar</code>. As regex podem ser usadas para detectar esses comandos de forma eficiente:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import re</span></span>
<span class="line"><span></span></span>
<span class="line"><span>padrao_comando = r&#39;^/\\w+&#39;</span></span>
<span class="line"><span>comandos_teste = [&quot;/ajuda&quot;, &quot;/iniciar&quot;, &quot;ajuda&quot;, &quot;iniciar/&quot;]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>for comando in comandos_teste:</span></span>
<span class="line"><span>    if re.match(padrao_comando, comando):</span></span>
<span class="line"><span>        print(f&quot;&#39;{comando}&#39; é um comando válido.&quot;)</span></span>
<span class="line"><span>    else:</span></span>
<span class="line"><span>        print(f&quot;&#39;{comando}&#39; não é um comando válido.&quot;)</span></span></code></pre></div><p>Este exemplo mostra como identificar strings que começam com uma barra seguida por um ou mais caracteres alfanuméricos.</p><h3 id="tokenizacao-simples" tabindex="-1">Tokenização Simples <a class="header-anchor" href="#tokenizacao-simples" aria-label="Permalink to &quot;Tokenização Simples&quot;">​</a></h3><p>Embora para tarefas complexas de PLN sejam utilizadas técnicas de tokenização mais avançadas, as regex podem ser úteis para realizar uma tokenização básica, dividindo o texto em palavras ou unidades menores com base em padrões de separação:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import re</span></span>
<span class="line"><span></span></span>
<span class="line"><span>texto = &quot;Olá, como vai você?&quot;</span></span>
<span class="line"><span>tokens = re.split(r&#39;\\W+&#39;, texto)</span></span>
<span class="line"><span>print(tokens)</span></span></code></pre></div><p>A saída será uma lista de strings, onde o padrão <code>\\W+</code> corresponde a um ou mais caracteres não alfanuméricos, utilizados como delimitadores.</p><h3 id="limpeza-de-texto" tabindex="-1">Limpeza de Texto <a class="header-anchor" href="#limpeza-de-texto" aria-label="Permalink to &quot;Limpeza de Texto&quot;">​</a></h3><p>Chatbots podem precisar processar texto que contém elementos indesejados, como tags HTML. As regex podem ser usadas para remover esses elementos:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import re</span></span>
<span class="line"><span></span></span>
<span class="line"><span>texto_html = &quot;&lt;p&gt;Este é um parágrafo com &lt;b&gt;texto em negrito&lt;/b&gt;.&lt;/p&gt;&quot;</span></span>
<span class="line"><span>texto_limpo = re.sub(r&#39;&lt;[^&gt;]+&gt;&#39;, &#39;&#39;, texto_html)</span></span>
<span class="line"><span>print(texto_limpo)</span></span></code></pre></div><h2 id="aplicacao-em-frameworks-de-chatbot" tabindex="-1">Aplicação em Frameworks de Chatbot <a class="header-anchor" href="#aplicacao-em-frameworks-de-chatbot" aria-label="Permalink to &quot;Aplicação em Frameworks de Chatbot&quot;">​</a></h2><p>Frameworks populares para desenvolvimento de chatbots, como Rasa, frequentemente integram o uso de expressões regulares para aprimorar a extração de entidades. Por exemplo, em Rasa, as regex podem ser definidas nos dados de treinamento para ajudar o sistema a reconhecer padrões específicos como nomes de ruas ou códigos de produtos. Essa abordagem permite melhorar a precisão do reconhecimento de entidades, um componente crucial para a compreensão da intenção do usuário.</p><h2 id="topicos-avancados" tabindex="-1">Tópicos Avançados <a class="header-anchor" href="#topicos-avancados" aria-label="Permalink to &quot;Tópicos Avançados&quot;">​</a></h2><p>Embora os fundamentos das regex sejam suficientes para muitas tarefas, existem construções mais avançadas que podem ser úteis em cenários complexos. Alguns exemplos incluem:</p><ul><li><p><strong>Lookaheads e Lookbehinds:</strong> Permitem verificar se um padrão é seguido ou precedido por outro padrão, sem incluir esse outro padrão na correspondência.</p></li><li><p><strong>Correspondência não-gulosa:</strong> Ao usar quantificadores como <code>*</code> ou <code>+</code>, a correspondência padrão é &quot;gulosa&quot;, ou seja, tenta corresponder à maior string possível. Adicionar um <code>?</code> após o quantificador (<code>*?</code>, <code>+?</code>) torna a correspondência &quot;não-gulosa&quot;, correspondendo à menor string possível.</p></li></ul><p>A exploração detalhada desses tópicos está além do escopo deste capítulo introdutório, mas são ferramentas poderosas para lidar com padrões mais complexos.</p><h2 id="limitacoes-e-contexto" tabindex="-1">Limitações e Contexto <a class="header-anchor" href="#limitacoes-e-contexto" aria-label="Permalink to &quot;Limitações e Contexto&quot;">​</a></h2><p>É importante reconhecer que, apesar de sua utilidade, as expressões regulares têm limitações significativas quando se trata de compreender a complexidade da linguagem natural. As regex são baseadas em padrões estáticos e não possuem a capacidade de entender o contexto, a semântica ou as nuances da linguagem humana.</p><p>Para tarefas que exigem uma compreensão mais profunda do significado e da intenção por trás das palavras, técnicas avançadas de Processamento de Linguagem Natural (PLN), como modelagem de linguagem, análise de sentimentos e reconhecimento de entidades nomeadas (NER) baseados em aprendizado de máquina, são indispensáveis.</p><p>No contexto de um fluxo de trabalho de chatbot, as expressões regulares são frequentemente mais eficazes nas etapas de pré-processamento, como limpeza e validação de entradas, enquanto técnicas de PLN mais sofisticadas são empregadas para a compreensão da linguagem em um nível mais alto. Os capítulos posteriores deste livro abordarão essas técnicas avançadas, incluindo o uso de Modelos de Linguagem Grandes (LLMs) e Retrieval-Augmented Generation (RAG), que complementam o uso de regex, permitindo a construção de chatbots mais inteligentes e contextualmente conscientes.</p><h2 id="conclusao" tabindex="-1">Conclusão <a class="header-anchor" href="#conclusao" aria-label="Permalink to &quot;Conclusão&quot;">​</a></h2><p>As expressões regulares representam uma ferramenta essencial para o processamento de texto em chatbots, oferecendo uma maneira eficaz de extrair informações específicas, validar formatos de entrada e realizar tarefas básicas de limpeza de texto. Através do módulo <code>re</code> em Python, os desenvolvedores têm à disposição um conjunto de funcionalidades poderosas para manipular strings com base em padrões definidos.</p><p>No entanto, é crucial entender as limitações das regex, especialmente no que diz respeito à compreensão da linguagem natural em sua totalidade. Para tarefas que exigem análise semântica e contextual, técnicas avançadas de PLN são necessárias. As expressões regulares, portanto, encontram seu melhor uso como parte de um fluxo de trabalho mais amplo, onde complementam outras abordagens para criar chatbots robustos e eficientes.</p><p>Encorajamos o leitor a praticar a criação de diferentes padrões de regex e a experimentar com os exemplos fornecidos neste capítulo. A familiaridade com as expressões regulares é uma habilidade valiosa para qualquer pessoa envolvida no desenvolvimento de chatbots e no processamento de linguagem natural em geral.</p>`,46)]))}const g=a(r,[["render",t]]);export{u as __pageData,g as default};
