<!DOCTYPE html>
<html lang="br" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>A Very Gentle Introduction to Large Language Models without the Hype | Neo</title>
    <meta name="description" content="Cursos">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/cursos/assets/style.gMdbKHz8.css" as="style">
    <link rel="preload stylesheet" href="/cursos/vp-icons.css" as="style">
    
    <script type="module" src="/cursos/assets/app.DqUz4ffb.js"></script>
    <link rel="preload" href="/cursos/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/cursos/assets/chunks/framework.H8_ecXae.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/theme.CvJUhm7k.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/katex.cqFQqex1.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/dagre-4EVJKHTY.CS5JLjZ8.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/c4Diagram-6F5ED5ID.CEe_2wbc.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/flowDiagram-7ASYPVHJ.BLtF-EKU.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/erDiagram-6RL3IURR.B61C1aNk.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/gitGraphDiagram-NRZ2UAAF.y0tMcKKG.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/ganttDiagram-NTVNEXSI.DrBwlnYb.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/infoDiagram-A4XQUW5V.CHR109JE.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/pieDiagram-YF2LJOPJ.DrJ5kyhK.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/quadrantDiagram-OS5C2QUG.B8313uV0.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/xychartDiagram-6QU3TZC5.BYuW0_jw.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/requirementDiagram-MIRIMTAZ.vAp5GdKJ.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/sequenceDiagram-G6AWOVSC.C6eiXqIP.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/classDiagram-LNE6IOMH.BvUMq1Rg.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/classDiagram-v2-MQ7JQ4JX.BvUMq1Rg.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/stateDiagram-MAYHULR4.yD5qN6uZ.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/stateDiagram-v2-4JROLMXI.C2Y7qmXO.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/journeyDiagram-G5WM74LC.CfCUG7qU.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/timeline-definition-U7ZMHBDA.DFamn6sm.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/mindmap-definition-GWI6TPTV.DR--9M5r.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/kanban-definition-QRCXZQQD.BLNvgyvD.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/sankeyDiagram-Y46BX6SQ.BTo7xGUV.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/diagram-QW4FP2JN.DQ6wlbrE.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/blockDiagram-ZHA2E4KO.DUSug9qD.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/architectureDiagram-UYN6MBPD.-W3Rt5K7.js">
    <link rel="modulepreload" href="/cursos/assets/chunks/virtual_mermaid-config.DDnGl6nM.js">
    <link rel="modulepreload" href="/cursos/assets/llm_verygentle.md.DuzCTuRI.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8d3e66f><!--[--><!--]--><!--[--><span tabindex="-1" data-v-b20e631d></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-b20e631d> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8d3e66f data-v-64278d09><div class="VPNavBar" data-v-64278d09 data-v-2f9a91a8><div class="wrapper" data-v-2f9a91a8><div class="container" data-v-2f9a91a8><div class="title" data-v-2f9a91a8><div class="VPNavBarTitle has-sidebar" data-v-2f9a91a8 data-v-db1abf29><a class="title" href="/cursos/" data-v-db1abf29><!--[--><!--]--><!----><span data-v-db1abf29>Neo</span><!--[--><!--]--></a></div></div><div class="content" data-v-2f9a91a8><div class="content-body" data-v-2f9a91a8><!--[--><!--]--><div class="VPNavBarSearch search" data-v-2f9a91a8><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-2f9a91a8 data-v-94e0de4d><span id="main-nav-aria-label" class="visually-hidden" data-v-94e0de4d> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/cursos/" tabindex="0" data-v-94e0de4d data-v-b04b12fe><!--[--><span data-v-b04b12fe>Home</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/cursos/pages/sobre.html" tabindex="0" data-v-94e0de4d data-v-b04b12fe><!--[--><span data-v-b04b12fe>Sobre</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-2f9a91a8 data-v-e6826308><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-e6826308 data-v-77e720fe data-v-b5a0f3c5><span class="check" data-v-b5a0f3c5><span class="icon" data-v-b5a0f3c5><!--[--><span class="vpi-sun sun" data-v-77e720fe></span><span class="vpi-moon moon" data-v-77e720fe></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-2f9a91a8 data-v-cb473b7f data-v-e0cde419><!--[--><a class="VPSocialLink no-icon" href="https://github.com/giseldo/curdos" aria-label="github" target="_blank" rel="noopener" data-v-e0cde419 data-v-6b91c750><span class="vpi-social-github"></span></a><a class="VPSocialLink no-icon" href="https://twitter.com/giseldoneo" aria-label="twitter" target="_blank" rel="noopener" data-v-e0cde419 data-v-6b91c750><span class="vpi-social-twitter"></span></a><a class="VPSocialLink no-icon" href="https://instagram.com/neogiseldo" aria-label="instagram" target="_blank" rel="noopener" data-v-e0cde419 data-v-6b91c750><span class="vpi-social-instagram"></span></a><a class="VPSocialLink no-icon" href="https://youtube.com/giseldoneo" aria-label="youtube" target="_blank" rel="noopener" data-v-e0cde419 data-v-6b91c750><span class="vpi-social-youtube"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-2f9a91a8 data-v-c4883afd data-v-3980e32a><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-3980e32a><span class="vpi-more-horizontal icon" data-v-3980e32a></span></button><div class="menu" data-v-3980e32a><div class="VPMenu" data-v-3980e32a data-v-f8f1a359><!----><!--[--><!--[--><!----><div class="group" data-v-c4883afd><div class="item appearance" data-v-c4883afd><p class="label" data-v-c4883afd>Appearance</p><div class="appearance-action" data-v-c4883afd><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-c4883afd data-v-77e720fe data-v-b5a0f3c5><span class="check" data-v-b5a0f3c5><span class="icon" data-v-b5a0f3c5><!--[--><span class="vpi-sun sun" data-v-77e720fe></span><span class="vpi-moon moon" data-v-77e720fe></span><!--]--></span></span></button></div></div></div><div class="group" data-v-c4883afd><div class="item social-links" data-v-c4883afd><div class="VPSocialLinks social-links-list" data-v-c4883afd data-v-e0cde419><!--[--><a class="VPSocialLink no-icon" href="https://github.com/giseldo/curdos" aria-label="github" target="_blank" rel="noopener" data-v-e0cde419 data-v-6b91c750><span class="vpi-social-github"></span></a><a class="VPSocialLink no-icon" href="https://twitter.com/giseldoneo" aria-label="twitter" target="_blank" rel="noopener" data-v-e0cde419 data-v-6b91c750><span class="vpi-social-twitter"></span></a><a class="VPSocialLink no-icon" href="https://instagram.com/neogiseldo" aria-label="instagram" target="_blank" rel="noopener" data-v-e0cde419 data-v-6b91c750><span class="vpi-social-instagram"></span></a><a class="VPSocialLink no-icon" href="https://youtube.com/giseldoneo" aria-label="youtube" target="_blank" rel="noopener" data-v-e0cde419 data-v-6b91c750><span class="vpi-social-youtube"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-2f9a91a8 data-v-6c970607><span class="container" data-v-6c970607><span class="top" data-v-6c970607></span><span class="middle" data-v-6c970607></span><span class="bottom" data-v-6c970607></span></span></button></div></div></div></div><div class="divider" data-v-2f9a91a8><div class="divider-line" data-v-2f9a91a8></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8d3e66f data-v-f3371c70><div class="container" data-v-f3371c70><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-f3371c70><span class="vpi-align-left menu-icon" data-v-f3371c70></span><span class="menu-text" data-v-f3371c70>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-f3371c70 data-v-7bf35b01><button data-v-7bf35b01>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-d8d3e66f data-v-77192a04><div class="curtain" data-v-77192a04></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-77192a04><span class="visually-hidden" id="sidebar-aria-label" data-v-77192a04> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-8e2b8225><section class="VPSidebarItem level-0 has-active" data-v-8e2b8225 data-v-bd6104a5><div class="item" role="button" tabindex="0" data-v-bd6104a5><div class="indicator" data-v-bd6104a5></div><h2 class="text" data-v-bd6104a5>LLM (medium)</h2><!----></div><div class="items" data-v-bd6104a5><!--[--><div class="VPSidebarItem level-1 is-link" data-v-bd6104a5 data-v-bd6104a5><div class="item" data-v-bd6104a5><div class="indicator" data-v-bd6104a5></div><a class="VPLink link link" href="/cursos/llm/" data-v-bd6104a5><!--[--><p class="text" data-v-bd6104a5>Large Language Models: A Short Introduction</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-bd6104a5 data-v-bd6104a5><div class="item" data-v-bd6104a5><div class="indicator" data-v-bd6104a5></div><a class="VPLink link link" href="/cursos/llm/verygentle.html" data-v-bd6104a5><!--[--><p class="text" data-v-bd6104a5>A Very Gentle Introduction to Large Language Models without the Hype</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8d3e66f data-v-6a411d75><div class="VPDoc has-sidebar has-aside" data-v-6a411d75 data-v-5e576dee><!--[--><!--]--><div class="container" data-v-5e576dee><div class="aside" data-v-5e576dee><div class="aside-curtain" data-v-5e576dee></div><div class="aside-container" data-v-5e576dee><div class="aside-content" data-v-5e576dee><div class="VPDocAside" data-v-5e576dee data-v-8e8afcfb><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-8e8afcfb data-v-f2249f6d><div class="content" data-v-f2249f6d><div class="outline-marker" data-v-f2249f6d></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f2249f6d>On this page</div><ul class="VPDocOutlineItem root" data-v-f2249f6d data-v-e7c3772a><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-8e8afcfb></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-5e576dee><div class="content-container" data-v-5e576dee><!--[--><!--]--><main class="main" data-v-5e576dee><div style="position:relative;" class="vp-doc _cursos_llm_verygentle" data-v-5e576dee><div><h1 id="a-very-gentle-introduction-to-large-language-models-without-the-hype" tabindex="-1">A Very Gentle Introduction to Large Language Models without the Hype <a class="header-anchor" href="#a-very-gentle-introduction-to-large-language-models-without-the-hype" aria-label="Permalink to &quot;A Very Gentle Introduction to Large Language Models without the Hype&quot;">​</a></h1><h2 id="sobre" tabindex="-1">Sobre <a class="header-anchor" href="#sobre" aria-label="Permalink to &quot;Sobre&quot;">​</a></h2><p>Esse artigo é uma tradução para o português do artigo no <a href="https://mark-riedl.medium.com/a-very-gentle-introduction-to-large-language-models-without-the-hype-5f67941fa59e" target="_blank" rel="noreferrer">medium</a></p><p><a href="https://mark-riedl.medium.com/" target="_blank" rel="noreferrer">Mais artigos do autor</a>. Um do scratch.</p><h2 id="introducao" tabindex="-1">Introdução <a class="header-anchor" href="#introducao" aria-label="Permalink to &quot;Introdução&quot;">​</a></h2><p>Este artigo foi criado para dar às pessoas sem formação em ciência da computação alguma visão sobre como o ChatGPT e sistemas de IA semelhantes funcionam (GPT-3, GPT-4, Bing Chat, Bard, etc.). O ChatGPT é um chatbot — um tipo de IA conversacional construída — mas em cima de um Large Language Model . Essas são definitivamente palavras e vamos decompô-las. No processo, discutiremos os conceitos principais por trás delas. Este artigo não requer nenhuma formação técnica ou matemática. Faremos uso intenso de metáforas para ilustrar os conceitos. Falaremos sobre por que os conceitos principais funcionam da maneira que funcionam e o que podemos ou não esperar que Large Language Models como o ChatGPT façam.</p><p>Aqui está o que faremos. Vamos percorrer gentilmente algumas das terminologias associadas a Large Language Models e ChatGPT sem nenhum jargão. Se eu tiver que usar jargão, vou destrinchar sem jargão. Começaremos bem básico, com &quot;o que é Inteligência Artificial&quot; e trabalharemos nosso caminho para cima. Usarei algumas metáforas recorrentes tanto quanto possível. Falarei sobre as implicações das tecnologias em termos do que devemos esperar que elas façam ou não.</p><p>Vamos!</p><h2 id="o-que-e-inteligencia-artificial" tabindex="-1">O que é Inteligência Artificial? <a class="header-anchor" href="#o-que-e-inteligencia-artificial" aria-label="Permalink to &quot;O que é Inteligência Artificial?&quot;">​</a></h2><p>Mas primeiro, vamos começar com alguma terminologia básica que você provavelmente está ouvindo bastante. O que é inteligência artificial ?</p><p>Inteligência artificial: Uma entidade que realiza comportamentos que uma pessoa poderia razoavelmente chamar de inteligentes se um humano fizesse algo semelhante.</p><p>É um pouco problemático definir inteligência artificial usando a palavra &quot;inteligente&quot;, mas ninguém consegue concordar com uma boa definição de &quot;inteligente&quot;. No entanto, acho que isso ainda funciona razoavelmente bem. Basicamente diz que se olharmos para algo artificial e ele fizer coisas que sejam envolventes e úteis e pareçam ser um tanto não triviais, então podemos chamá-lo de inteligente. Por exemplo, frequentemente atribuímos o termo &quot;IA&quot; a personagens controlados por computador em jogos de computador. A maioria desses bots são simples pedaços de código if-then-else (por exemplo, &quot;se o jogador estiver dentro do alcance, atire, senão mova-se para a pedra mais próxima para se proteger&quot;). Mas se estamos fazendo o trabalho de nos manter envolvidos e entretidos, e não fazendo coisas obviamente estúpidas, então podemos pensar que eles são mais sofisticados do que são.</p><p>Uma vez que conseguimos entender como algo funciona, podemos não ficar muito impressionados e esperar algo mais sofisticado nos bastidores. Tudo depende do que você sabe sobre o que está acontecendo nos bastidores.</p><p>O ponto-chave é que a inteligência artificial não é mágica. E porque não é mágica, pode ser explicada.</p><p>Então vamos lá.</p><h2 id="o-que-e-aprendizado-de-maquina" tabindex="-1">O que é aprendizado de máquina? <a class="header-anchor" href="#o-que-e-aprendizado-de-maquina" aria-label="Permalink to &quot;O que é aprendizado de máquina?&quot;">​</a></h2><p>Outro termo que você ouvirá frequentemente associado à inteligência artificial é aprendizado de máquina .</p><p>Aprendizado de máquina : um meio pelo qual é possível criar comportamento ao receber dados, formar um modelo e, então, executar o modelo. Às vezes é muito difícil criar manualmente um monte de instruções if-then-else para capturar algum fenômeno complicado, como a linguagem. Neste caso, tentamos encontrar um monte de dados e usar algoritmos que podem encontrar padrões nos dados para modelar.</p><p>Mas o que é um modelo? Um modelo é uma simplificação de algum fenômeno complexo. Por exemplo, um carro modelo é apenas uma versão menor e mais simples de um carro real que tem muitos dos atributos, mas não se destina a substituir completamente o original. Um carro modelo pode parecer real e ser útil para certos propósitos, mas não podemos levá-lo até a loja.</p><p>Uma imagem gerada por DALL-E de um modelo de carro sobre uma mesa. Assim como podemos fazer uma versão menor e mais simples de um carro, também podemos fazer uma versão menor e mais simples da linguagem humana. Usamos o termo modelos de linguagem grandes porque esses modelos são, bem, grandes, da perspectiva de quanta memória é necessária para usá-los. Os maiores modelos em produção, como ChatGPT, GPT-3 e GPT-4, são grandes o suficiente para exigir supercomputadores massivos em execução em servidores de data center para criar e executar.</p><h2 id="o-que-e-uma-rede-neural" tabindex="-1">O que é uma rede neural? <a class="header-anchor" href="#o-que-e-uma-rede-neural" aria-label="Permalink to &quot;O que é uma rede neural?&quot;">​</a></h2><p>Há muitas maneiras de aprender um modelo a partir de dados. A Rede Neural é uma delas. A técnica é baseada aproximadamente em como o cérebro humano é composto por uma rede de células cerebrais interconectadas chamadas neurônios que passam sinais elétricos de um lado para o outro, de alguma forma nos permitindo fazer todas as coisas que fazemos. O conceito básico da rede neural foi inventado na década de 1940 e os conceitos básicos sobre como treiná-las foram inventados na década de 1980. As redes neurais são muito ineficientes, e foi somente por volta de 2017 que o hardware do computador ficou bom o suficiente para usá-las em larga escala.</p><p>Mas em vez de cérebros, eu gosto de pensar em redes neurais usando a metáfora de circuitos elétricos. Você não precisa ser um engenheiro elétrico para saber que a eletricidade flui através de fios e que temos coisas chamadas resistores que tornam mais difícil para a eletricidade fluir através de partes de um circuito.</p><p>Imagine que você queira fazer um carro autônomo que possa dirigir na rodovia. Você equipou seu carro com sensores de proximidade na frente, atrás e nas laterais. Os sensores de proximidade relatam um valor de 1,0 quando há algo muito próximo e relatam um valor de 0,0 quando nada é detectável por perto.</p><p>Você também equipou seu carro para que mecanismos robóticos possam girar o volante, acionar os freios e acionar o acelerador. Quando o acelerador recebe um valor de 1,0, ele usa aceleração máxima, e 0,0 significa nenhuma aceleração. Da mesma forma, um valor de 1,0 enviado ao mecanismo de frenagem significa pisar fundo nos freios e 0,0 significa nenhuma frenagem. O mecanismo de direção assume um valor de -1,0 a +1,0 com um valor negativo significando virar para a esquerda e um valor positivo significando virar para a direita e 0,0 significando manter-se reto.</p><p>Você também registrou dados sobre como você dirige. Quando a estrada à sua frente está limpa, você acelera. Quando há um carro na sua frente, você desacelera. Quando um carro se aproxima muito à esquerda, você vira à direita e muda de faixa. A menos, é claro, que haja um carro à sua direita também. É um processo complexo que envolve diferentes combinações de ações (virar para a esquerda, virar para a direita, acelerar mais ou menos, frear) com base em diferentes combinações de informações do sensor.</p><p>Agora você tem que conectar o sensor aos mecanismos robóticos. Como você faz isso? Não está claro. Então você conecta cada sensor a cada atuador robótico.</p><p><img src="/cursos/assets/image-3.B3zcjjM7.png" alt="alt text"></p><p>Uma rede neural como um circuito que conecta sensores a atuadores. O que acontece quando você leva seu carro para a estrada? A corrente elétrica flui de todos os sensores para todos os atuadores robóticos e o carro simultaneamente vira para a esquerda, vira para a direita, acelera e freia. É uma bagunça.</p><p><img src="/cursos/assets/image-4.B47WeLo1.png" alt="alt text"></p><p>Quando alguns dos nossos sensores enviam energia, essa energia flui para todos os atuadores e o carro acelera, freia e dirige ao mesmo tempo. Isso não é bom. Então eu pego meus resistores e começo a colocá-los em diferentes partes dos circuitos para que a eletricidade possa fluir mais livremente entre certos sensores e certos atuadores robóticos. Por exemplo, eu quero que a eletricidade flua mais livremente dos sensores de proximidade dianteiros para os freios e não para o volante. Eu também coloco coisas chamadas gates, que interrompem o fluxo de eletricidade até que eletricidade suficiente se acumule para acionar um interruptor (permitir que a eletricidade flua apenas quando o sensor de proximidade dianteiro e o sensor de proximidade traseiro estiverem relatando números altos), ou enviar energia elétrica para frente apenas quando a força elétrica de entrada estiver baixa (enviar mais eletricidade para o acelerador quando o sensor de proximidade dianteiro estiver relatando um valor baixo).</p><p>Mas onde coloco esses resistores e gates? Não sei. Começo a colocá-los aleatoriamente em todos os lugares. Então tento novamente. Talvez dessa vez meu carro dirija melhor, o que significa que às vezes ele freia quando os dados dizem que é melhor frear e vira quando os dados dizem que é melhor virar, etc. Mas ele não faz tudo certo. E faz algumas coisas pior (acelera quando os dados dizem que é melhor frear). Então continuo tentando aleatoriamente diferentes combinações de resistores e gates. Eventualmente, vou tropeçar em uma combinação que funciona bem o suficiente para que eu declare sucesso. Talvez pareça com isso:</p><p><img src="/cursos/assets/image-5.DnCcr-gP.png" alt="alt text"></p><p>Uma rede neural totalmente treinada. Linhas mais escuras significam partes do circuito onde a energia flui mais livremente. Círculos no meio são portões que podem acumular muita energia de baixo antes de enviar qualquer energia para cima, ou possivelmente até mesmo enviar energia para cima quando há pouca energia abaixo. (Na realidade, não adicionamos ou subtraímos portas, que estão sempre lá, mas modificamos as portas para que sejam ativadas com menos energia de baixo ou exijam mais energia de baixo, ou talvez liberem muita energia somente quando há muito pouca energia de baixo. Os puristas do aprendizado de máquina podem vomitar um pouco na boca com essa caracterização. Tecnicamente, isso é feito ajustando algo chamado polarização nas portas, que normalmente não é mostrado em diagramas como esses, mas em termos da metáfora do circuito pode ser pensado como um fio entrando em cada porta conectado diretamente a uma fonte elétrica, que pode então ser modificado como todos os outros fios.)</p><p>Vamos fazer um test drive!</p><p><img src="/cursos/assets/image-6.D7qDJrEt.png" alt="alt text"></p><p>Tentar coisas aleatoriamente é uma droga. Um algoritmo chamado retropropagação é razoavelmente bom em fazer suposições sobre como mudar a configuração do circuito. Os detalhes do algoritmo não são importantes, exceto saber que ele faz pequenas mudanças no circuito para deixar o comportamento do circuito mais próximo de fazer o que os dados sugerem, e ao longo de milhares ou milhões de ajustes, pode eventualmente obter algo próximo de concordar com os dados.</p><p>Chamamos os resistores e gates de parâmetros porque, na realidade, eles estão em todos os lugares e o que o algoritmo de retropropagação está fazendo é declarar que cada resistor é mais forte ou mais fraco. Assim, o circuito inteiro pode ser reproduzido em outros carros se soubermos o layout dos circuitos e os valores dos parâmetros.</p><h2 id="o-que-e-deep-learning" tabindex="-1">O que é Deep Learning? <a class="header-anchor" href="#o-que-e-deep-learning" aria-label="Permalink to &quot;O que é Deep Learning?&quot;">​</a></h2><p>Deep Learning é um reconhecimento de que podemos colocar outras coisas em nossos circuitos além de resistores e gates. Por exemplo, podemos ter um cálculo matemático no meio do nosso circuito que soma e multiplica coisas antes de enviar eletricidade adiante. Deep Learning ainda usa a mesma técnica incremental básica de adivinhar parâmetros.</p><h2 id="o-que-e-um-modelo-de-linguagem" tabindex="-1">O que é um modelo de linguagem? <a class="header-anchor" href="#o-que-e-um-modelo-de-linguagem" aria-label="Permalink to &quot;O que é um modelo de linguagem?&quot;">​</a></h2><p>Quando fizemos o exemplo do carro, estávamos tentando fazer com que nossa rede neural realizasse um comportamento que fosse consistente com nossos dados. Estávamos perguntando se poderíamos criar um circuito que manipulasse os mecanismos do carro da mesma forma que um motorista fez em circunstâncias semelhantes. Podemos tratar a linguagem da mesma forma. Podemos olhar para um texto escrito por humanos e imaginar se um circuito poderia produzir uma sequência de palavras que se parecesse muito com as sequências de palavras que os humanos tendem a produzir. Agora, nossos sensores disparam quando vemos palavras e nossos mecanismos de saída também são palavras.</p><p>O que estamos tentando fazer? Estamos tentando criar um circuito que adivinha uma palavra de saída, dado um monte de palavras de entrada. Por exemplo:</p><p>“Era uma vez ____”</p><p>parece que deveria preencher a lacuna com “tempo”, mas não com “tatu”.</p><p>Nós tendemos a falar sobre modelos de linguagem em termos de probabilidade. Matematicamente, escreveremos o exemplo acima como:</p><p><img src="/cursos/assets/image-7.Bvi9ujHH.png" alt="alt text"></p><p>Se você não estiver familiarizado com a notação, não se preocupe. Isso é apenas conversa de matemática, significando a probabilidade ( P ) da palavra “tempo” dado (o símbolo de barra | significa dado ) um monte de palavras “uma vez”, “sobre” e “a”. Esperaríamos que um bom modelo de linguagem produzisse uma probabilidade maior da palavra “tempo” do que para a palavra “armadillo”.</p><p>Podemos generalizar isso para:</p><p><img src="/cursos/assets/image-8.DT9BEn8l.png" alt="alt text"></p><p>que significa apenas calcular a probabilidade da n -ésima palavra em uma sequência, dadas todas as palavras que vêm antes dela (palavras nas posições de 1 a n -1).</p><p>Mas vamos recuar um pouco. Pense em uma máquina de escrever antiga, do tipo com braços de percussão.</p><p>DALL-E2 fez esta imagem. Olhe para todos os braços de ataque! Exceto que em vez de ter um braço de percussão diferente para cada letra, temos um percussor para cada palavra. Se a língua inglesa tem 50.000 palavras, então esta é uma grande máquina de escrever!</p><p><img src="/cursos/assets/image-9.bbty_jcw.png" alt="alt text"></p><p>Em vez da rede para o carro, pense em uma rede similar, exceto que o topo do nosso circuito tem 50.000 saídas conectadas a braços de percussão, uma para cada palavra. Correspondentemente, teríamos 50.000 sensores, cada um detectando a presença de uma palavra de entrada diferente. Então, o que estamos fazendo no final do dia é escolher um único braço de percussão que obtém o sinal elétrico mais alto e essa é a palavra que vai no espaço em branco.</p><p>Aqui é onde estamos: se eu quiser fazer um circuito simples que receba uma única palavra e produza uma única palavra, eu teria que fazer um circuito que tivesse 50.000 sensores (um para cada palavra) e 50.000 saídas (uma para cada braço de percussão). Eu apenas conectaria cada sensor a cada braço de percussão para um total de 50.000 x 50.000 = 2,5 bilhões de fios.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Uma palavra para outra palavra</p><p>50.000 x 50.000</p><p>2,5 bilhões de fios.</p></div><p><img src="/cursos/assets/gif04.Cct09ZGh.gif" alt="alt text"></p><p>Cada círculo na parte inferior detecta uma palavra. São necessários 50.000 sensores para reconhecer a palavra “once”. Essa energia é enviada por alguma rede arbitrária. Todos os círculos na parte superior são conectados a braços de ataque para cada palavra. Todos os braços de ataque recebem alguma energia, mas um receberá mais do que os outros. Essa é uma grande rede!</p><p>Mas piora. Se eu quiser fazer o exemplo “Era uma vez ___”, preciso sentir qual palavra está em cada uma das três posições de entrada. Eu precisaria de 50.000 x 3 = 150.000 sensores. Conectados a 50.000 braços de ataque, terei 150.000 x 50.000 = 7,5 bilhões de fios. Em 2023, a maioria dos grandes modelos de linguagem pode aceitar 4.000 palavras, com o maior aceitando 32.000 palavras. Meus olhos estão lacrimejando.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Três palavras para uma palavra</p><p>50.000 x 3 = 150.000</p><p>150.000 x 50.000</p><p>7,5 bilhões de fios</p></div><p><img src="/cursos/assets/gif03.ukz5MOu7.gif" alt="alt text"></p><p>Uma rede que recebe três palavras como entrada requer 50.000 sensores por palavra. Vamos precisar de alguns truques para lidar com essa situação. Vamos fazer as coisas em etapas.</p><h2 id="codificadores" tabindex="-1">Codificadores <a class="header-anchor" href="#codificadores" aria-label="Permalink to &quot;Codificadores&quot;">​</a></h2><p>A primeira coisa que faremos é dividir nosso circuito em dois circuitos, um chamado encoder e outro chamado decoder . A ideia é que muitas palavras significam aproximadamente a mesma coisa. Considere as seguintes frases:</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>A ideia é que muitas palavras significam aproximadamente a mesma coisa.</p></div><ul><li>O rei sentou-se no ___</li><li>A rainha sentou-se no ___</li><li>A princesa sentou-se no ___</li><li>O regente sentou-se no ___</li></ul><p>Um palpite razoável para todos os espaços em branco acima seria “trono” (ou talvez “banheiro”). O que quer dizer que eu não precisaria de fios separados entre “rei” e “trono”, ou entre “rainha” e “trono”, etc. Em vez disso, seria ótimo se eu tivesse algo que significasse aproximadamente realeza e toda vez que eu visse “rei” ou “rainha”, eu usasse essa coisa intermediária. Então eu só teria que me preocupar com quais palavras significam aproximadamente a mesma coisa e então o que fazer sobre isso (enviar muita energia para “trono”).</p><p>Então aqui está o que faremos. Vamos montar um circuito que pega 50.000 sensores de palavras e mapeia para um conjunto menor de saídas, digamos 256 em vez de 50.000. E em vez de poder acionar apenas um braço de ataque, podemos esmagar vários braços de uma vez. Cada combinação possível de braços de ataque pode representar um conceito diferente (como &quot;realeza&quot; ou &quot;mamíferos blindados&quot;). Essas 256 saídas nos dariam a capacidade de representar conceitos de 2²⁵⁶ = 1,15 x 10⁷⁸. Na realidade, é ainda mais porque, como no exemplo do carro, podemos pressionar os freios parcialmente, cada uma dessas 256 saídas pode ser não apenas 1,0 ou 0,0, mas qualquer número entre eles. Então, talvez a melhor metáfora para isso seja que todos os 256 braços de ataque esmagam para baixo, mas cada um esmaga para baixo com uma quantidade diferente de força.</p><p>Ok... então, anteriormente, uma palavra exigiria um de 50.000 sensores para disparar. Agora, fervemos um sensor ativado e 49.999 sensores desligados em 256 números. Então, &quot;rei&quot; pode ser [0,1, 0,0 , 0,9, …, 0,4] e &quot;rainha&quot; pode ser [0,1, 0,1 , 0,9, …, 0,4], que são quase iguais. Chamarei essas listas de números de codificações (também chamadas de estado oculto por razões históricas, mas não quero explicar isso, então ficaremos com a codificação). Chamamos o circuito que espreme nossos 50.000 sensores em 256 saídas de codificador . Parece com isso:</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Encode</p><p>50.000 x 256</p><p>12,8 milhões</p></div><p><img src="/cursos/assets/gif02.BL4xqVck.gif" alt="alt text"></p><p>Uma rede de codificadores que comprime os 50.000 valores de sensores necessários para detectar uma única palavra em uma codificação de 256 números (azul mais claro e mais escuro usado para indicar valores maiores ou menores).</p><h2 id="decodificadores" tabindex="-1">Decodificadores <a class="header-anchor" href="#decodificadores" aria-label="Permalink to &quot;Decodificadores&quot;">​</a></h2><p>Mas o codificador não nos diz qual palavra deve vir em seguida. Então, nós pareamos nosso codificador com uma rede de decodificadores . O decodificador é outro circuito que pega 256 números que compõem a codificação e ativa os 50.000 braços de percussão originais, um para cada palavra. Nós então escolheríamos a palavra com a maior saída elétrica. É assim que ficaria:</p><p><img src="/cursos/assets/gif01.C5o_Hb1M.gif" alt="alt text"></p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Decode</p><p>256 x 50.000</p><p>12,8 milhões</p></div><p>Uma rede decodificadora, expandindo os 256 valores na codificação em valores de ativação para os 50.000 braços de ataque associados a cada palavra possível. Uma palavra ativa o mais alto.</p><h2 id="codificadores-e-decodificadores-juntos" tabindex="-1">Codificadores e decodificadores juntos <a class="header-anchor" href="#codificadores-e-decodificadores-juntos" aria-label="Permalink to &quot;Codificadores e decodificadores juntos&quot;">​</a></h2><p>Aqui está o codificador e o decodificador trabalhando juntos para formar uma grande rede neural:</p><p><img src="/cursos/assets/image-15.DB1YRCi4.png" alt="alt text"></p><p>Uma rede codificador-decodificador. É apenas um decodificador em cima de um codificador. E, a propósito, uma única entrada de palavra para uma única saída de palavra passando por codificação precisa apenas de (50.000 x 256) x 2 = 25,6 milhões de parâmetros. Isso parece muito melhor.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Encode-decode</p><p>(50.000 x 256) x 2</p><p>25,6 milhões de parâmetros</p><p>Antes tínhamos - Uma palavra para outra palavra:</p><p>50.000 x 50.000</p><p>2,5 bilhões de fios.</p></div><p>Esse exemplo foi para uma entrada de palavra e produzindo uma saída de palavra, então teríamos 50.000 x n entradas se quiséssemos ler n palavras e 256 x n para a codificação</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Encode de 3 palavras e decode de uma palavra</p><p>(50.000 x 256 x 3) + (50.000 x 256)</p><p>38.400 + 12.800</p><p>51,2 milhões de parâmetros</p><p>Antes tínhamos - Três palavras para uma palavra</p><p>50.000 x 3 = 150.000</p><p>150.000 x 50.000</p><p>7,5 bilhões de fios</p></div><p>Mas por que isso funciona? Ao forçar 50.000 palavras a caberem em um pequeno conjunto de números, forçamos a rede a fazer concessões e agrupar palavras que podem disparar o mesmo palpite de palavra de saída. Isso é muito parecido com a compactação de arquivo. Quando você compacta um documento de texto, obtém um documento menor que não é mais legível. Mas você pode descompactar o documento e recuperar o texto original legível. Isso pode ser feito porque o programa zip substitui certos padrões de palavras por uma notação abreviada. Então, quando ele descompacta, ele sabe qual texto trocar de volta para a notação abreviada. Nossos circuitos codificadores e decodificadores aprendem uma configuração de resistores e portas que compactam e descompactam palavras.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Como se fosse compactar e descompactar um documento</p></div><h2 id="auto-supervisao" tabindex="-1">Auto-Supervisão () <a class="header-anchor" href="#auto-supervisao" aria-label="Permalink to &quot;Auto-Supervisão ()&quot;">​</a></h2><p>Como sabemos qual codificação para cada palavra é melhor? Em outras palavras, como sabemos que a codificação para “rei” deve ser similar à codificação para “rainha” em vez de “armadillo”?</p><p>Como um experimento mental, considere uma rede codificadora-decodificadora que deve receber uma única palavra (50.000 sensores) e produzir exatamente a mesma palavra como saída. Isso é uma coisa boba de se fazer, mas é bem instrutiva para o que virá a seguir.</p><p><img src="/cursos/assets/gif05.oKtzL1BR.gif" alt="alt text"></p><p>Uma rede codificadora-decodificadora treinada para gerar a mesma palavra que a entrada (é a mesma imagem de antes, mas com cor para ativação).</p><p>Eu coloco a palavra &quot;rei&quot; e um único sensor envia seu sinal elétrico através do codificador e liga parcialmente 256 valores na codificação no meio. Se a codificação estiver correta, o decodificador enviará o sinal elétrico mais alto para a mesma palavra, &quot;rei&quot;. Certo, fácil? Não tão rápido. É tão provável que eu veja o braço da máquina de escrever com a palavra “armadillo” com a energia de ativação mais alta. Suponha que o braço da máquina de escrever para &quot;rei&quot; receba 0,051 de sinal elétrico e o braço atacante para “armadillo” receba 0,23 de sinal elétrico. Na verdade, nem me importo com o valor para “armadillo”. Posso apenas olhar para a energia de saída para &quot;rei&quot; e saber que não era 1,0. A diferença entre 1,0 e 0,051 é o erro (também chamado de perda ) e posso usar a retropropagação para fazer algumas alterações no decodificador e no codificador para que uma codificação ligeiramente diferente seja feita na próxima vez que virmos a palavra &quot;rei&quot;.</p><p>Fazemos isso para todas as palavras. O codificador vai ter que fazer um acordo porque o 256 é bem menor que 50.000. Ou seja, algumas palavras vão ter que usar as mesmas combinações de energia de ativação no meio. Então, quando tiver a escolha, ele vai querer que a codificação para &quot;rei&quot; e &quot;rainha&quot; seja quase idêntica e a codificação para &quot;“armadillo”&quot; seja bem diferente. Isso dará ao decodificador uma chance melhor de adivinhar a palavra apenas olhando para os valores de codificação 256. E se o decodificador vir uma combinação particular de valores 256 e adivinhar &quot;rei&quot; com 0,43 e &quot;rainha&quot; com 0,42, vamos ficar bem com isso, desde que &quot;rei&quot; e &quot;rainha&quot; recebam os sinais elétricos mais altos e cada um dos 49.998 braços de ataque receba números menores. Outra maneira de dizer isso é que provavelmente ficaremos mais tranquilos se a rede ficar confusa entre reis e rainhas do que se a rede ficar confusa entre reis e “armadillos”.</p><p>Dizemos que a rede neural é autossupervisionada porque, diferentemente do exemplo do carro, você não precisa coletar dados separados para testar a saída. Apenas comparamos a saída com a entrada — não precisamos ter dados separados para a entrada e a saída.</p><h2 id="modelos-de-linguagem-mascarada" tabindex="-1">Modelos de Linguagem Mascarada <a class="header-anchor" href="#modelos-de-linguagem-mascarada" aria-label="Permalink to &quot;Modelos de Linguagem Mascarada&quot;">​</a></h2><p>Se o experimento mental acima parece bobo, ele é um bloco de construção para algo chamado modelos de linguagem mascarada . A ideia de um modelo de linguagem mascarada é pegar uma sequência de palavras e gerar uma sequência de palavras. Uma das palavras na entrada e na saída são apagadas.</p><p>A [MÁSCARA] estava sentada no trono.</p><p>A rede adivinha todas as palavras. Bem, é bem fácil adivinhar as palavras desmascaradas. Nós só nos importamos com o palpite da rede sobre a palavra mascarada. Ou seja, temos 50.000 braços de striker para cada palavra na saída. Olhamos para os 50.000 braços de striker para a palavra mascarada.</p><p><img src="/cursos/assets/image-16.B7yD55kd.png" alt="alt text"></p><p>Mascarando uma sequência. Estou ficando cansado de desenhar muitas linhas de conexão, então vou desenhar apenas linhas vermelhas para significar muitas e muitas conexões entre tudo acima e abaixo. Podemos mover a máscara e fazer com que a rede adivinhe palavras diferentes em lugares diferentes.</p><p>Um tipo especial de modelo de linguagem mascarada tem apenas a máscara no final. Isso é chamado de modelo generativo porque a máscara que ele está supondo é sempre a próxima palavra na sequência, o que é equivalente a gerar a próxima palavra como se a próxima palavra não existisse. Assim:</p><ul><li>A [MÁSCARA]</li><li>A rainha [MÁSCARA]</li><li>A rainha sentou-se [MÁSCARA]</li><li>A rainha sentou-se em [MÁSCARA]</li><li>A rainha sentou-se em [MÁSCARA]</li></ul><p>Também chamamos isso de modelo autorregressivo . A palavra regressivo não soa tão bem. Mas regressão significa apenas tentar entender a relação entre as coisas, como palavras que foram inseridas e palavras que deveriam ser produzidas. Auto significa “self”. Um modelo autorregressivo é autopreditivo. Ele prevê uma palavra. Então essa palavra é usada para prever a próxima palavra, que é usada para prever a próxima palavra, e assim por diante. Há algumas implicações interessantes para isso, às quais voltaremos mais tarde.</p><h2 id="o-que-e-um-transformador" tabindex="-1">O que é um transformador? <a class="header-anchor" href="#o-que-e-um-transformador" aria-label="Permalink to &quot;O que é um transformador?&quot;">​</a></h2><p>No momento em que este texto foi escrito, ouvimos muito sobre coisas chamadas GPT-3 e GPT-4 e ChatGPT. GPT é uma marca particular de um tipo de modelo de linguagem grande desenvolvido por uma empresa chamada OpenAI. GPT significa Generative Pre-trained Transformer . Vamos decompor isso:</p><p>Generativo. O modelo é capaz de gerar continuações para a entrada fornecida. Ou seja, dado algum texto, o modelo tenta adivinhar quais palavras vêm em seguida. Pré-treinado . O modelo é treinado em um corpus muito grande de texto geral e deve ser treinado uma vez e usado para muitas coisas diferentes sem precisar ser treinado novamente do zero. Mais sobre pré-treinamento… O modelo é treinado em um corpus muito grande de texto geral que aparentemente cobre um grande número de tópicos concebíveis. Isso significa mais ou menos &quot;raspado da internet&quot; em vez de retirado de alguns repositórios de texto especializados. Ao treinar em texto geral, um modelo de linguagem é mais capaz de responder a uma gama mais ampla de entradas do que, por exemplo, um modelo de linguagem treinado em um tipo muito específico de texto, como de documentos médicos. Um modelo de linguagem treinado em um corpus geral pode teoricamente responder razoavelmente a qualquer coisa que possa aparecer em um documento na internet. Ele pode se sair bem com texto médico. Um modelo de linguagem treinado apenas em documentos médicos pode responder muito bem a entradas relacionadas a contextos médicos, mas ser muito ruim em responder a outras entradas, como bate-papo ou receitas.</p><p>Ou o modelo é bom o suficiente em tantas coisas que nunca é preciso treinar o próprio modelo, ou é possível fazer algo chamado ajuste fino , que significa pegar o modelo pré-treinado e fazer algumas atualizações para que ele funcione melhor em uma tarefa especializada (como médica).</p><p>Agora para o transformador…</p><p>Transformer. Um tipo específico de modelo de deep learning de codificador-decodificador autosupervisionado com algumas propriedades muito interessantes que o tornam bom em modelagem de linguagem. Um transformador é um tipo particular de modelo de aprendizado profundo que transforma a codificação de uma forma particular que torna mais fácil adivinhar a palavra apagada. Foi introduzido por um artigo chamado Attention is All You Need por Vaswani et al. em 2017. No coração de um transformador está a rede clássica codificador-decodificador. O codificador faz um processo de codificação muito padrão. Tão simples que você ficaria chocado. Mas então ele adiciona outra coisa chamada autoatenção .</p><h2 id="autoatencao" tabindex="-1">Autoatenção <a class="header-anchor" href="#autoatencao" aria-label="Permalink to &quot;Autoatenção&quot;">​</a></h2><p>Aqui está a ideia de autoatenção: certas palavras em uma sequência estão relacionadas a outras palavras na sequência. Considere a frase &quot;O alienígena pousou na Terra porque precisava se esconder em um planeta&quot;. Se mascarássemos a segunda palavra, &quot;alienígena&quot;, e pedíssemos a uma rede neural para adivinhar a palavra, ela teria uma chance melhor por causa de palavras como &quot;pousou&quot; e &quot;terra&quot;. Da mesma forma, se mascarássemos &quot;isso&quot; e pedíssemos à rede para adivinhar a palavra, a presença da palavra &quot;alienígena&quot; poderia torná-la mais propensa a preferir &quot;isso&quot; a &quot;ele&quot; ou &quot;ela&quot;.</p><p><img src="/cursos/assets/image-17.Dw40NnnR.png" alt="alt text"></p><p>As palavras se relacionam com outras palavras por função, referindo-se à mesma coisa ou informando os significados umas das outras. Dizemos que palavras em uma sequência atendem a outras palavras porque elas capturam algum tipo de relacionamento. O relacionamento não é necessariamente conhecido. Pode ser resolver pronomes, pode ser relação de verbo e sujeito, pode ser duas palavras relacionadas ao mesmo conceito (“terra” e “planeta”). Seja o que for, saber que há algum tipo de relação entre palavras é útil para previsão.</p><p>A próxima seção abordará a matemática da autoatenção, mas o ponto principal é que um transformador aprende quais palavras em uma sequência de entrada são relacionadas e, então, cria uma nova codificação para cada posição na sequência de entrada que é uma fusão de todas as palavras relacionadas. Você pode pensar nisso como aprender a criar uma nova palavra que é uma mistura de “alienígena” e “aterrado” e “terra” (aliandearth?). Isso funciona porque cada palavra é codificada como uma lista de números. Se alien = [0,1, 0,2, 0,3, …, 0,4] e landed = [0,5, 0,6, 0,7, …, 0,8] e earth = [0,9, 1,0, 1,1, …, 1,2], então a segunda posição da palavra pode ser codificada como a soma de todas essas codificações, [1,5, 1,8, 2,1, …, 2,4], que por si só não corresponde a nenhuma palavra, mas captura partes de todas as palavras. Dessa forma, quando o decodificador finalmente vê essa nova codificação para a palavra na segunda posição, ele tem muitas informações sobre como a palavra estava sendo usada na sequência e, portanto, faz uma estimativa melhor sobre quaisquer máscaras. (O exemplo apenas adiciona a codificação, mas será um pouco mais complicado do que isso).</p><h2 id="como-funciona-a-autoatencao" tabindex="-1">Como funciona a autoatenção? <a class="header-anchor" href="#como-funciona-a-autoatencao" aria-label="Permalink to &quot;Como funciona a autoatenção?&quot;">​</a></h2><p>Autoatenção é uma melhoria significativa em relação às redes de codificador-decodificador vanilla, então se você quiser saber mais sobre como isso funciona, continue lendo. Caso contrário, sinta-se à vontade para pular esta seção. TL;DR: autoatenção é um nome chique para a operação matemática chamada produto escalar .</p><p>A autoatenção acontece em três estágios.</p><p>(1) Codificamos cada palavra na sequência de entrada normalmente. Fazemos quatro cópias das codificações de palavras. Uma chamamos de residual e reservamos para guardar em segurança.</p><p>(2) Executamos uma segunda rodada de codificação (estamos codificando uma codificação) nos outros três. Cada um passa por um processo de codificação diferente, então todos se tornam diferentes. Chamamos um de consulta ( q ), um de chave ( k ) e um de valor ( v ).</p><p>Quero que você pense em uma tabela hash (também chamada de dicionário em python). Você tem um monte de informações armazenadas em uma tabela. Cada linha na tabela tem uma chave , algum identificador exclusivo e o valor , os dados sendo armazenados na linha. Para recuperar algumas informações da tabela hash, você faz uma consulta. Se a consulta corresponder à chave, você extrai o valor.</p><p><img src="/cursos/assets/image-18.J-JeVAGV.png" alt="alt text"></p><p>Uma tabela hash que pode ser usada para consultar em qual universidade um professor trabalha. A autoatenção funciona um pouco como uma tabela hash fuzzy . Você fornece uma consulta e, em vez de procurar uma correspondência exata com uma chave, ela encontra correspondências aproximadas com base na similaridade entre consulta e chave. Mas e se a correspondência não for uma correspondência perfeita? Ela retorna alguma fração do valor. Bem, isso só faz sentido se a consulta, as chaves e os valores forem todos numéricos. Que são:</p><p><img src="/cursos/assets/image-19.DF3RGVOc.png" alt="alt text"></p><p>Uma tabela hash com correspondências parciais. Então é isso que faremos. Para cada posição de palavra na entrada, pegaremos a codificação q e a codificação k e calcularemos a similaridade. Usamos algo chamado produto escalar, também chamado de similaridade de cosseno. Não é importante. O ponto é que cada palavra é uma lista de 256 números (com base em nosso exemplo anterior) e podemos calcular a similaridade das listas de números e registrar a similaridade em uma matriz. Chamamos essa matriz de pontuações de autoatenção . Se tivéssemos uma sequência de entrada de três palavras, nossas pontuações de atenção poderiam ser algo assim:</p><p><img src="/cursos/assets/image-20.VqOYs686.png" alt="alt text"></p><p>Cada célula indica o quanto a palavra codificada em uma posição atende à palavra codificada em outra posição. A rede trata a primeira palavra como uma consulta e ela corresponde à segunda chave (podemos dizer que a primeira palavra está “atendendo” à segunda palavra). Se a segunda palavra fosse uma consulta, ela corresponderia à terceira chave. Se a terceira palavra fosse uma consulta, ela corresponderia à primeira chave. Na realidade, nunca teríamos uns e zeros assim; teríamos correspondências parciais entre 0 e 1 e cada consulta (linha) corresponderia parcialmente a várias chaves (colunas).</p><p>Agora, para continuar com a metáfora de recuperação, multiplicamos essa matriz contra as codificações v e algo interessante acontece. Suponha que nossas codificações v se parecessem com isso:</p><p><img src="/cursos/assets/image-21.CXg3G8fb.png" alt="alt text"></p><p>Cada linha é uma codificação para uma palavra em uma sequência. Isto é, a primeira palavra foi codificada como uma lista de números 0,10…0,19, a segunda palavra foi codificada como uma lista de números 0,20…0,29, e a terceira palavra foi codificada como uma lista de números 0,30…0,39. Esses números são feitos para fins ilustrativos e nunca seriam tão arrumados.</p><p><img src="/cursos/assets/image-22.C3w1cL0a.png" alt="alt text"></p><p>Multiplicando atenção com valores. A primeira consulta corresponde à segunda chave e, portanto, recupera a segunda palavra codificada. A segunda consulta corresponde à terceira chave e, portanto, recupera a terceira palavra codificada. A terceira consulta corresponde à primeira chave e, portanto, recupera a primeira palavra codificada. O que efetivamente fizemos foi trocar linhas!</p><p><img src="/cursos/assets/image-23.Bxe5gKPw.png" alt="alt text"></p><p>Na prática, as pontuações não seriam uns e zeros perfeitos e o resultado seria um pouco de cada codificação misturada (por exemplo, 97% da palavra um mais 1% ou palavra três mais 2% da palavra dois). Mas isso ilustra como a autoatenção é uma mistura e troca. Nesta versão extrema, a primeira palavra foi trocada pela segunda palavra, e assim por diante. Então, talvez a palavra “terra” tenha sido trocada pela palavra “planeta”.</p><p>Como sabemos que codificamos q , k e v corretamente? Se a capacidade geral da rede de adivinhar a melhor palavra para a máscara melhorar, então estamos codificando q , k e v corretamente. Se não, alteramos os parâmetros para codificar um pouco diferente na próxima vez.</p><p>(3) A terceira coisa que fazemos é pegar o resultado de toda essa matemática e adicioná-lo ao residual. Lembre-se daquela primeira cópia da codificação original que deixamos de lado. Isso mesmo, adicionamos a versão misturada e trocada a ela. Agora, “terra” não é apenas uma codificação de “terra”, mas algum tipo de palavra imaginária que é uma mistura de “terra” e “planeta”… pearth? ealanet? Não é bem assim. De qualquer forma, esta é a codificação final transformada que será enviada ao decodificador. Provavelmente podemos concordar que ter uma palavra falsa em cada posição que realmente codifica duas ou mais palavras é mais útil para fazer previsões com base em uma única palavra por posição.</p><p>Depois, faça isso várias vezes, uma após a outra (várias camadas).</p><p>Estou deixando de fora muitos detalhes sobre como a codificação final do codificador entra no decodificador (outra rodada de atenção, chamada de atenção de fonte , onde as codificações do codificador de cada posição são usadas como q e k para serem aplicadas contra outra versão diferente de v ), mas neste ponto você deve ter uma ideia geral das coisas. No final, o decodificador, recebendo a codificação do codificador, envia energia para os braços do percussor para as palavras, e escolhemos a palavra mais fortemente energizada.</p><ol start="7"><li>Por que os grandes modelos de linguagem são tão poderosos? Então o que tudo isso significa? Grandes modelos de linguagem, incluindo ChatGPT, GPT-4 e outros, fazem exatamente uma coisa: eles pegam um monte de palavras e tentam adivinhar qual palavra deve vir a seguir. Se isso é “raciocínio” ou “pensamento”, então é apenas uma forma muito especializada.</li></ol><p>Mas mesmo essa forma especializada parece muito poderosa porque o ChatGPT e similares podem fazer muitas coisas aparentemente muito bem: escrever poesia, responder perguntas sobre ciência e tecnologia, resumir documentos, rascunhar e-mails e até mesmo escrever código, para citar apenas algumas coisas. Por que eles deveriam funcionar tão bem?</p><p>O molho secreto é duplo. O primeiro já falamos: o transformador aprende a misturar contextos de palavras de uma forma que o torna realmente bom em adivinhar a próxima palavra. A outra parte do molho secreto é como os sistemas são treinados. Grandes Modelos de Linguagem são treinados em grandes quantidades de informações extraídas da internet. Isso inclui livros, blogs, sites de notícias, artigos da Wikipedia, discussões no Reddit, conversas em mídias sociais. Durante o treinamento, alimentamos um trecho de texto de uma dessas fontes e pedimos que ele adivinhe a próxima palavra. Lembre-se: autossupervisionado. Se ele adivinhar errado, ajustamos o modelo um pouco até que ele acerte. Se fôssemos pensar sobre o que um LLM é treinado para fazer, é produzir texto que poderia ter aparecido razoavelmente na internet. Ele não consegue memorizar a internet, então ele usa as codificações para fazer concessões e erra um pouco, mas espero que não muito.</p><p>É importante não subestimar o quão diverso é o texto na internet em termos de tópicos. Os LLMs já viram de tudo. Eles já viram bilhões de conversas sobre quase todos os tópicos. Então, um LLM pode produzir palavras que parecem estar conversando com você. Ele já viu bilhões de poemas e letras de música sobre quase tudo que é concebível, então ele pode produzir um texto que parece poesia. Ele já viu bilhões de tarefas de casa e suas soluções, então ele pode fazer suposições razoáveis ​​sobre sua tarefa, mesmo que ligeiramente diferentes. Ele já viu bilhões de perguntas de testes padronizados e suas respostas. Nós realmente achamos que as perguntas do SAT deste ano são tão diferentes das do ano passado? Ele viu pessoas falando sobre seus planos de férias, então ele pode adivinhar palavras que parecem planos de férias. Ele já viu bilhões de exemplos de código fazendo todo tipo de coisa. Muito do que os programadores de computador fazem é montar pedaços de código para fazer coisas muito típicas e bem compreendidas em pedaços maiores de código. Assim, os LLMs podem escrever esses pequenos trechos comuns para você. Ele viu bilhões de exemplos de códigos errados e suas correções no stackoverflow.com. Sim, então ele pode pegar seu código quebrado e sugerir correções. Ele viu bilhões de pessoas tuitando que tocaram em um fogão quente e queimaram os dedos, então os LLMs sabem um pouco de bom senso. Ele leu muitos artigos científicos, então ele pode adivinhar fatos científicos bem conhecidos, mesmo que eles não sejam bem conhecidos por você. Ele viu bilhões de exemplos de pessoas resumindo, reescrevendo texto em marcadores, descrevendo como tornar o texto mais gramatical, conciso ou persuasivo.</p><p>Aqui está o ponto: quando você pede ao ChatGPT ou outro Large Language Model para fazer algo inteligente — e funciona — há uma chance muito boa de que você tenha pedido para fazer algo que ele já viu bilhões de exemplos. E mesmo se você inventar algo realmente único como &quot;me diga o que Flash Gordon faria depois de comer seis burritos&quot; (isso é único, eu nem sei), ele viu Fan Fiction sobre Flash Gordon e viu pessoas falando sobre comer muitos burritos e pode — por causa da autoatenção — misturar e combinar pedaços e peças para montar uma resposta que soe razoável.</p><p>Nosso primeiro instinto ao interagir com um Large Language Model não deve ser &quot;uau, essas coisas devem ser realmente inteligentes ou realmente criativas ou realmente compreensivas&quot;. Nosso primeiro instinto deve ser &quot;Eu provavelmente pedi para ele fazer algo que ele já viu em pedaços antes&quot;. Isso pode significar que ele ainda é realmente útil, mesmo que não esteja &quot;pensando muito&quot; ou &quot;fazendo algum raciocínio realmente sofisticado&quot;.</p><p>Não precisamos usar a antropomorfização para entender o que ela está fazendo para nos fornecer uma resposta.</p><p>Uma nota final sobre este tema: devido à maneira como os Large Language Models funcionam e à maneira como são treinados, eles tendem a fornecer respostas que são, de certa forma, a resposta mediana. Pode parecer muito estranho para mim dizer que o modelo tende a dar respostas medianas após pedir uma história sobre Flash Gordon. Mas no contexto de uma história, ou um poema, as respostas podem ser pensadas como sendo o que muitas pessoas (escrevendo na internet) inventariam se tivessem que se comprometer. Não será ruim. Pode ser muito bom para os padrões de uma única pessoa sentada tentando pensar em algo por conta própria. Mas suas histórias e poemas provavelmente também são medianos (mas são especiais para você). Desculpe.</p><h2 id="o-que-devo-observar" tabindex="-1">O que devo observar? <a class="header-anchor" href="#o-que-devo-observar" aria-label="Permalink to &quot;O que devo observar?&quot;">​</a></h2><p>Há algumas implicações realmente sutis que surgem de como os Transformers funcionam e como são treinados. As seguintes são implicações diretas dos detalhes técnicos.</p><p>Grandes Modelos de Linguagem são treinados na internet. Isso significa que eles também foram treinados em todas as partes obscuras da humanidade. Grandes Modelos de Linguagem foram treinados em discursos racistas, discursos sexistas, insultos de todo tipo contra todo tipo de pessoa, pessoas fazendo suposições estereotipadas sobre outras, teorias da conspiração, desinformação política, etc. Isso significa que as palavras que um modelo de linguagem escolhe gerar podem regurgitar tal linguagem.</p><p>Grandes modelos de linguagem não têm “crenças centrais”. Eles são adivinhadores de palavras; eles estão tentando prever quais seriam as próximas palavras se a mesma frase aparecesse na internet. Assim, pode-se pedir a um grande modelo de linguagem para escrever uma frase a favor de algo, ou contra essa mesma coisa, e o modelo de linguagem obedecerá de ambas as maneiras. Essas não são indicações de que ele acredita em uma coisa ou outra, ou muda suas crenças, ou que uma está mais certa do que a outra. Se os dados de treinamento tiverem mais exemplos de uma coisa em relação a outra, então um grande modelo de linguagem tenderá a responder de forma mais consistente com o que aparecer em seus dados de treinamento com mais frequência, porque aparece na internet com mais frequência. Lembre-se: o modelo está se esforçando para emular a resposta mais comum. Grandes Modelos de Linguagem não têm nenhum senso de verdade ou certo ou errado. Há coisas que consideramos fatos, como a Terra ser redonda. Um LLM tenderá a dizer isso. Mas se o contexto estiver certo, ele também dirá o oposto porque a internet tem texto sobre a Terra ser plana. Não há garantia de que um LLM fornecerá a verdade. Pode haver uma tendência a adivinhar palavras que concordamos serem verdadeiras, mas isso é o mais próximo que podemos chegar de fazer qualquer afirmação sobre o que um LLM “sabe” sobre a verdade ou o certo ou errado.</p><p>Grandes modelos de linguagem podem cometer erros. Os dados de treinamento podem ter muito material inconsistente. A autoatenção pode não atender a todas as coisas que queremos quando fazemos uma pergunta. Como um adivinhador de palavras, ele pode fazer suposições infelizes. Às vezes, os dados de treinamento viram uma palavra tantas vezes que preferem essa palavra mesmo quando ela não faz sentido para a entrada. O acima leva a um fenômeno que é chamado de &quot; alucinação &quot;, onde uma palavra é adivinhada que não é derivada da entrada nem &quot;correta&quot;. Os LLMs têm inclinações para adivinhar números pequenos em vez de números grandes porque números pequenos são mais comuns. Então, os LLMs não são bons em matemática. Os LLMs têm uma preferência pelo número &quot;42&quot; porque os humanos têm por causa de um livro famoso em particular. Os LLMs têm preferências por nomes mais comuns, então podem inventar os nomes de autores. Grandes modelos de linguagem são auto-regressivos. Assim, quando eles fazem suposições que podemos considerar ruins, essas palavras adivinhadas são adicionadas às suas próprias entradas para fazer a próxima palavra adivinhar. Ou seja: os erros se acumulam. Mesmo que haja apenas 1% de chance de erro, então a autoatenção pode atender a essa escolha errada e dobrar esse erro. Mesmo que apenas um erro seja cometido, tudo o que vem depois pode estar vinculado a esse erro. Então o modelo de linguagem pode cometer erros adicionais além disso. Os transformadores não têm uma maneira de &quot;mudar de ideia&quot; ou tentar novamente ou se autocorrigir. Eles seguem o fluxo.</p><p>Deve-se sempre verificar as saídas de um modelo de linguagem grande. Se você está pedindo para ele fazer coisas que você não pode verificar competentemente, então você deve pensar se está tudo bem em agir em quaisquer erros que sejam cometidos. Para tarefas de baixo risco, como escrever um conto, isso pode ser bom. Para tarefas de alto risco, como tentar obter informações para decidir em quais ações investir, talvez esses erros possam fazer com que você tome uma decisão muito custosa.</p><p>Autoatenção significa que quanto mais informações você fornecer no prompt de entrada, mais especializada será a resposta, porque ela misturará mais palavras suas em seus palpites. A qualidade da resposta é diretamente proporcional à qualidade do prompt de entrada. Melhores prompts produzem melhores resultados. Tente vários prompts diferentes e veja o que funciona melhor para você. Não presuma que o modelo de linguagem &quot;entende&quot; o que você está tentando fazer e dará o melhor de si na primeira vez.</p><p>Você não está realmente &quot;tendo uma conversa&quot; com um modelo de linguagem grande. Um modelo de linguagem grande não &quot;lembra&quot; o que aconteceu na troca. Sua entrada entra. A resposta sai. O LLM não lembra de nada. Sua entrada inicial, a resposta e sua resposta à resposta entram. Portanto, se parece que está se lembrando, é porque o log das conversas se torna uma nova entrada. Este é um truque de programação no front-end para fazer o Modelo de Linguagem Grande parecer que está tendo uma conversa. Ele provavelmente permanecerá no tópico por causa deste truque, mas não há garantia de que não contradirá suas respostas anteriores. Além disso, há um limite para quantas palavras podem ser alimentadas no modelo de linguagem grande (atualmente, o ChatGPT permite aproximadamente 4.000 palavras, e o GPT-4 permite aproximadamente 32.000 palavras). Os tamanhos de entrada podem ser muito grandes, então a conversa frequentemente parecerá permanecer coerente por um tempo. Eventualmente, o log acumulado ficará muito grande e o início da conversa será excluído e o sistema &quot;esquecerá&quot; coisas anteriores.</p><p>Grandes modelos de linguagem não resolvem problemas ou planejam. Mas você pode pedir que eles criem planos e resolvam problemas. Vou dividir alguns detalhes aqui. Resolução de problemas e planejamento são termos reservados por certos grupos na comunidade de pesquisa de IA para significar algo muito específico. Em particular, eles significam ter uma meta — algo que você quer realizar no futuro — e trabalhar para atingir essa meta fazendo escolhas entre alternativas que provavelmente nos levarão mais perto dessa meta. Grandes modelos de linguagem não têm metas. Eles têm um objetivo, que é escolher uma palavra que provavelmente apareceria nos dados de treinamento dada uma sequência de entrada. Eles são correspondências de padrões. O planejamento, em particular, geralmente envolve algo chamado look-ahead . Quando os humanos planejam, eles imaginam os resultados de suas ações e analisam esse futuro com relação à meta. Se parece que nos aproxima de uma meta, é uma boa jogada. Se não, podemos tentar imaginar os resultados de outra ação. Há muito mais do que isso, mas os pontos-chave são que os grandes modelos de linguagem não têm objetivos e não fazem look-ahead . Os transformadores são retrospectivos. A autoatenção só pode ser aplicada às palavras de entrada que já apareceram. Agora, os grandes modelos de linguagem podem gerar saídas que parecem planos porque eles viram muitos planos nos dados de treinamento. Eles sabem como os planos se parecem, eles sabem o que deve aparecer nos planos sobre certos tópicos que eles viram. Ele fará um bom palpite sobre esse plano. O plano pode ignorar detalhes particulares sobre o mundo e tender para o plano mais genérico. Os grandes modelos de linguagem certamente não &quot;pensaram nas alternativas&quot; ou tentaram uma coisa e voltaram atrás e tentaram outra coisa. Não há nenhum mecanismo dentro de um transformador que alguém possa apontar que faria tal consideração de ida e volta do futuro. (Há uma ressalva para isso, que surgirá na próxima seção.) Sempre verifique as saídas ao solicitar planos.</p><h2 id="o-que-torna-o-chatgpt-tao-especial" tabindex="-1">O que torna o ChatGPT tão especial? <a class="header-anchor" href="#o-que-torna-o-chatgpt-tao-especial" aria-label="Permalink to &quot;O que torna o ChatGPT tão especial?&quot;">​</a></h2><p>“Então ouvi dizer que RLHF é o que torna o ChatGPT realmente inteligente.”</p><p>“O ChatGPT usa aprendizado por reforço e é isso que o torna tão inteligente.”</p><p>Bem... mais ou menos.</p><p>No momento em que este texto foi escrito, havia muita empolgação sobre algo chamado RLHF, ou Reinforcement Learning with Human Feedback . Há algumas coisas que foram feitas para treinar o ChatGPT em particular (e cada vez mais outros Large Language Models). Elas não são exatamente novas, mas foram amplamente introduzidas com grande efeito quando o ChatGPT foi lançado.</p><p>O ChatGPT é um Transformer baseado em Large Language Model. O ChatGPT ganhou a reputação de ser muito bom em produzir respostas a prompts de entrada e por se recusar a responder perguntas sobre certos tópicos que podem ser considerados tóxicos ou opinativos. Ele não faz nada particularmente diferente do que foi descrito acima. Na verdade, é bem simples. Mas há uma diferença: como ele foi treinado. O ChatGPT foi treinado normalmente — raspando uma grande parte da internet, pegando trechos desse texto e fazendo o sistema prever a próxima palavra. Isso resultou em um modelo base que já era um preditor de palavras muito poderoso (equivalente ao GPT-3). Mas então houve duas etapas adicionais de treinamento. Ajuste de instruções e aprendizado por reforço com feedback humano.</p><h2 id="ajuste-de-instrucoes" tabindex="-1">Ajuste de instruções <a class="header-anchor" href="#ajuste-de-instrucoes" aria-label="Permalink to &quot;Ajuste de instruções&quot;">​</a></h2><p>Há um problema específico com modelos de linguagem grandes: eles só querem pegar uma sequência de entrada de palavras e gerar o que vem a seguir. Na maioria das vezes, é isso que se quer. Mas nem sempre. Considere o seguinte prompt de entrada:</p><p>“Escreva um ensaio sobre Alexander Hamilton.”</p><p>O que você acha que a resposta deveria ser. Você provavelmente está pensando que deveria ser algo como “Alexander Hamilton nasceu em Nevis em 1757. Ele era um estadista, um advogado, coronel do Exército e o primeiro Secretário do Tesouro dos Estados Unidos…” Mas o que você pode realmente obter é:</p><p>“Seu ensaio deve ter pelo menos cinco páginas, espaço duplo e incluir pelo menos duas citações.”</p><p>O que aconteceu? Bem, o modelo de linguagem pode ter visto muitos exemplos de tarefas de alunos que começam com “Escreva uma redação sobre…” e incluem palavras detalhando o comprimento e a formatação. Claro que quando você escreveu “Escreva uma redação…” você estava pensando que estava escrevendo instruções para o modelo de linguagem como se fosse um humano que entendesse a intenção. Os modelos de linguagem não entendem sua intenção ou têm suas próprias intenções; eles apenas correspondem as entradas aos padrões que viram em seus dados de treinamento.</p><p>Para consertar isso, pode-se fazer algo chamado ajuste de instrução . A ideia é bem simples. Se você obtiver a resposta errada, anote qual deve ser a resposta correta e envie a entrada original e a nova saída corrigida pela rede neural como dados de treinamento. Com exemplos suficientes da saída corrigida, o sistema aprenderá a mudar seu circuito para que a nova resposta seja preferida.</p><p>Não é preciso fazer nada muito extravagante. Basta fazer com que muitas pessoas interajam com o grande modelo de linguagem e peçam para ele fazer muitas coisas e anotar as correções quando ele não se comportar corretamente. Então, colete todos os exemplos em que ele cometeu erros e as novas saídas corretas e faça mais treinamento.</p><p>Isso faz com que o modelo de linguagem grande aja como se entendesse a intenção dos prompts de entrada e aja como se estivesse seguindo instruções. Ele não está fazendo nada além de tentar adivinhar a próxima palavra. Mas agora os novos dados de treinamento o fazem adivinhar palavras que parecem mais responsivas à entrada.</p><h2 id="aprendizagem-por-reforco-a-partir-do-feedback-humano" tabindex="-1">Aprendizagem por reforço a partir do feedback humano <a class="header-anchor" href="#aprendizagem-por-reforco-a-partir-do-feedback-humano" aria-label="Permalink to &quot;Aprendizagem por reforço a partir do feedback humano&quot;">​</a></h2><p>O próximo passo no treinamento é o aprendizado por reforço a partir do feedback humano. Acho que isso vai exigir um pouco de explicação.</p><p>Aprendizado por reforço é uma técnica de IA tradicionalmente usada em algumas pesquisas de robótica e também em agentes de jogos virtuais (pense em sistemas de IA que podem jogar Xadrez, Go ou StarCraft). O aprendizado por reforço é especialmente bom em descobrir o que fazer quando recebe algo chamado recompensa . Recompensa é apenas um número que indica o quão bem ele está se saindo (+100 para se sair muito bem; -100 para se sair muito mal). No mundo real e em jogos, a recompensa é frequentemente dada raramente. Em um jogo, você pode ter que fazer muitos movimentos antes de ganhar algum ponto. Talvez você só ganhe pontos no final do jogo. No mundo real, simplesmente não há pessoas suficientes dizendo quando você está fazendo um bom trabalho (você está). A menos que você seja um cachorro (eles são todos bons meninos e meninas). A única coisa que você realmente precisa saber é que os sistemas de aprendizado por reforço tentam prever quanta recompensa futura eles receberão e, em seguida, escolhem a ação que provavelmente obterá mais recompensa futura. Não é totalmente diferente da maneira como alguém pode usar petiscos para cães para ensinar seu cão a se comportar.</p><p>Certo, guarde tudo isso e considere o seguinte prompt:</p><p>Em que Mark é especialista?</p><p>Suponha que a saída do modelo de linguagem seja:</p><p>Mark tem muitas publicações em inteligência artificial, gráficos e interação humano-computador.</p><p>Isso está apenas parcialmente correto. Eu não publico em gráficos. Eu realmente gostaria de dar um polegar para baixo, ou uma pontuação de -1. Mas apenas uma parte está errada: a palavra gráficos. Se eu dissesse ao sistema que a frase inteira está errada, o modelo de linguagem poderia aprender que todas essas palavras devem ser evitadas. Bem, muitas dessas palavras são razoáveis.</p><p>É aqui que entra o aprendizado por reforço. O aprendizado por reforço funciona tentando diferentes alternativas e vendo quais alternativas obtêm a maior recompensa. Suponha que eu pedisse para ele gerar três respostas diferentes para o prompt original.</p><p>Mark tem muitas publicações em inteligência artificial, gráficos e interação humano-computador.</p><p>Mark trabalhou em inteligência artificial, sistemas seguros de PNL e interação humano-computador.</p><p>Mark pesquisou inteligência artificial, IA de jogos e gráficos.</p><p>Eu poderia dar um polegar para baixo (-1) para a primeira alternativa, um polegar para cima (+1) para a segunda alternativa e um polegar para baixo (-1) para a terceira alternativa. Assim como jogar um jogo, um algoritmo de aprendizado por reforço pode olhar para trás e descobrir que a única coisa em comum que resulta em um -1 é a palavra &quot;gráficos&quot;. Agora o sistema pode se concentrar nessa palavra e ajustar o circuito da rede neural para não usar essa palavra em conjunto com esse prompt de entrada específico.</p><p>Mais uma vez, faremos com que um grupo de pessoas interaja com o modelo de linguagem grande. Desta vez, daremos às pessoas três (ou mais) respostas possíveis. Podemos fazer isso pedindo ao modelo de linguagem grande para responder a um prompt várias vezes e introduzir um pouco de aleatoriedade na seleção dos braços de ataque (não se esqueceu deles, não é?). Em vez de escolher o braço de ataque mais ativado, às vezes podemos escolher o segundo ou terceiro braço de ataque mais ativado. Isso dá respostas de texto diferentes, e pedimos às pessoas para escolherem sua primeira resposta favorita, segunda favorita e assim por diante. Agora temos alternativas e números. Agora podemos usar o aprendizado por reforço para ajustar o circuito da rede neural.</p><p>[Na verdade, usamos esses feedbacks de polegar para cima e polegar para baixo para treinar uma segunda rede neural para prever se as pessoas darão um polegar para cima ou um polegar para baixo. Se essa rede neural for boa o suficiente para prever o que as pessoas preferirão, então podemos usar essa segunda rede neural para adivinhar se as respostas do modelo de linguagem podem receber polegar para cima ou polegar para baixo e usar isso para treinar o modelo de linguagem.]</p><p>O que o aprendizado por reforço faz? Ele trata a geração de texto como um jogo em que cada ação é uma palavra. No final de uma sequência, o modelo de linguagem é informado se ganhou alguns pontos ou perdeu alguns pontos. O modelo de linguagem não está exatamente fazendo uma previsão como discutido na seção anterior, mas foi, em certo sentido, treinado para prever quais palavras receberão aprovação. O Large Language Model ainda não tem um objetivo explícito, mas tem um objetivo implícito de &quot;receber aprovação&quot; (ou também poderíamos dizer que tem o objetivo implícito de &quot;satisfazer a pessoa média&quot;) e aprendeu a correlacionar certas respostas a certos prompts com a obtenção de aprovação. Isso tem muitas qualidades de planejamento, mas sem um mecanismo explícito de previsão. Mais como se tivesse estratégias memorizadas para obter recompensas que tendem a funcionar em muitas situações.</p><p>Sobre o ponto principal de se o RLHF torna o ChatGPT mais inteligente... ele torna o ChatGPT mais propenso a produzir os tipos de respostas que esperávamos ver. Ele parece mais inteligente porque suas saídas parecem transmitir uma sensação de que ele entende as intenções de nossas entradas e tem suas próprias intenções de responder. Isso é uma ilusão porque ele ainda está apenas codificando e decodificando palavras. Mas, novamente, é aí que começamos este artigo 😉.</p><p>O ajuste de instruções e o RLHF também tornam o uso do ChatGPT resistente a certos tipos de abusos, como a geração de conteúdo racista, sexista ou politicamente carregado. Ainda pode ser feito e, em qualquer caso, versões mais antigas do GPT-3 sempre foram capazes de fazer isso. No entanto, como um serviço público gratuito, o atrito que o ChatGPT cria contra certos tipos de abuso transmite uma sensação de segurança. Ele também é resistente a fornecer opinião como fato, o que também elimina uma forma de danos potenciais ao usuário.</p><p>[Usar aprendizado por reforço para modificar um modelo de linguagem pré-treinado não é novidade. Ele pode ser rastreado até pelo menos 2016 e tem sido usado para tornar modelos de linguagem grandes mais seguros. A maioria dos ajustes baseados em aprendizado por reforço de modelos de linguagem grandes usa um segundo modelo para fornecer recompensa, o que também é feito com o ChatGPT. O que o ChatGPT é notável é a escala do sistema sendo ajustado com aprendizado por reforço e o esforço de coleta de feedback humano em larga escala.]</p><h2 id="conclusoes" tabindex="-1">Conclusões <a class="header-anchor" href="#conclusoes" aria-label="Permalink to &quot;Conclusões&quot;">​</a></h2><p>Quando desenho redes neurais à mão, parece barbatana de baleia. De qualquer forma, espero ter conseguido filtrar um pouco do hype em torno dos Large Language Models.</p></div></div></main><footer class="VPDocFooter" data-v-5e576dee data-v-7ae10264><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-7ae10264><span class="visually-hidden" id="doc-footer-aria-label" data-v-7ae10264>Pager</span><div class="pager" data-v-7ae10264><a class="VPLink link pager-link prev" href="/cursos/llm/" data-v-7ae10264><!--[--><span class="desc" data-v-7ae10264>Previous page</span><span class="title" data-v-7ae10264>Large Language Models: A Short Introduction</span><!--]--></a></div><div class="pager" data-v-7ae10264><!----></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8d3e66f data-v-bc8227f9><div class="container" data-v-bc8227f9><p class="message" data-v-bc8227f9>Todos os direitos reservados.</p><p class="copyright" data-v-bc8227f9>© 2025 Giseldo Neo</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"am_cap2.md\":\"x3NvxdqF\",\"am_cap3.md\":\"BtGjcjWf\",\"am_index.md\":\"DigP7ArE\",\"articles_index.md\":\"C7Mt2id-\",\"chatbot_1-como-criar.md\":\"CkqO3fMZ\",\"chatbot_index.md\":\"OUy16CBP\",\"chatbotbook_10_criando_chatbots_com_llms_e_engenharia_de_prompts.md\":\"DNKigl2h\",\"chatbotbook_11_expressoes_regulares.md\":\"osAODM6B\",\"chatbotbook_12_usando_o_gpt2.md\":\"D-H33u5W\",\"chatbotbook_1_chatbots_definicoes_e_contexto.md\":\"BGxMcwuT\",\"chatbotbook_2_eliza_explicado.md\":\"ByWPpVoi\",\"chatbotbook_3_artificial_intelligence_markup_language.md\":\"DQMZ0nFt\",\"chatbotbook_4_processamento_de_linguagem_natural.md\":\"WY2sGEeX\",\"chatbotbook_5_intencao_em_chatbots_chap_intents_.md\":\"B8OSs2At\",\"chatbotbook_6_llm.md\":\"7ifnhO8p\",\"chatbotbook_7_retrieval_augmented_generation.md\":\"BrDHPyOZ\",\"chatbotbook_8_chatbot_eliza_em_python.md\":\"bTenI0I5\",\"chatbotbook_9_usando_chatgpt_com_langchain.md\":\"D4egKQI_\",\"chatbotbook_index.md\":\"B7Hsp0JO\",\"estatistica_index.md\":\"BjUwvP_I\",\"estatistica_pag2.md\":\"rgL7p3Rm\",\"index.md\":\"BCGw6IZ2\",\"llm_index.md\":\"CX8hg49b\",\"llm_verygentle.md\":\"DuzCTuRI\",\"nlp_index.md\":\"DEgCtiV1\",\"pages_sobre.md\":\"DSMqWM9v\",\"pln_1-introducao.md\":\"CJZkSIqo\",\"pln_2-transformers.md\":\"BKFuHYHT\",\"pln_index.md\":\"Bhk6lKr7\",\"pln_parte-2.md\":\"DbrFs6t7\",\"regressao_1-intro.md\":\"D69i_U4K\",\"regressao_2-video.md\":\"Cb9Xx3Xk\",\"regressao_3-exercicios.md\":\"Cipf-cx8\",\"regressao_index.md\":\"DBkEe3hL\",\"transformers_index.md\":\"CL2o6vqW\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"br\",\"dir\":\"ltr\",\"title\":\"Neo\",\"description\":\"Cursos\",\"base\":\"/cursos/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"outline\":{\"level\":[2,3]},\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"Sobre\",\"link\":\"/pages/sobre\"}],\"sidebar\":{\"/chatbotbook/\":[{\"text\":\"Chatbotbook\",\"items\":[{\"text\":\"Index\",\"link\":\"/chatbotbook/\"},{\"text\":\"Definições e contexto\",\"link\":\"/chatbotbook/1_chatbots_definicoes_e_contexto\"},{\"text\":\"Eliza Explicado\",\"link\":\"/chatbotbook/2_eliza_explicado\"},{\"text\":\"Artificial Intelligence Markup Language\",\"link\":\"/chatbotbook/3_artificial_intelligence_markup_language\"},{\"text\":\"Processamento de Linguagem Natural\",\"link\":\"/chatbotbook/4_processamento_de_linguagem_natural\"},{\"text\":\"Intenção em chatbots\",\"link\":\"/chatbotbook/5_intencao_em_chatbots_chap_intents_\"},{\"text\":\"Large Language Models\",\"link\":\"/chatbotbook/6_llm\"},{\"text\":\"Retrieval Augmented Generation\",\"link\":\"/chatbotbook/7_retrieval_augmented_generation\"},{\"text\":\"Chatbot Eliza em Python\",\"link\":\"/chatbotbook/8_chatbot_eliza_em_python\"},{\"text\":\"Usando Chatgpt com Langchain\",\"link\":\"/chatbotbook/9_usando_chatgpt_com_langchain\"},{\"text\":\"Criando Chatbots com LLMs através da Engenharia de Prompts\",\"link\":\"/chatbotbook/10_criando_chatbots_com_llms_e_engenharia_de_prompts\"},{\"text\":\"Expressões Regulares\",\"link\":\"/chatbotbook/11_expressoes_regulares\"},{\"text\":\"Usando o Gpt2\",\"link\":\"/chatbotbook/12_usando_o_gpt2\"}]}],\"/estatistica/\":[{\"text\":\"Estatística\",\"items\":[{\"text\":\"Pag 1\",\"link\":\"/estatistica/\"},{\"text\":\"Pag 2\",\"link\":\"/estatistica/pag2\"}]}],\"/am/\":[{\"text\":\"AM\",\"items\":[{\"text\":\"Introdução\",\"link\":\"/am/\"},{\"text\":\"Pag 2\",\"link\":\"/am/cap2\"},{\"text\":\"Pag 3\",\"link\":\"/am/cap3\"},{\"text\":\"Pag 4\",\"link\":\"/am/cap4\"},{\"text\":\"Pag 4\",\"link\":\"/am/cap5\"}]}],\"/pln/\":[{\"text\":\"Processamento de linguagem natural\",\"items\":[{\"text\":\"Sobre\",\"link\":\"/pln/\"},{\"text\":\"Introdução\",\"link\":\"/pln/1-introducao\"},{\"text\":\"Transformers\",\"link\":\"/pln/2-transformers\"}]}],\"/nlp/\":[{\"text\":\"NLP\",\"items\":[{\"text\":\"Introdução\",\"link\":\"/nlp/\"}]}],\"/llm/\":[{\"text\":\"LLM (medium)\",\"items\":[{\"text\":\"Large Language Models: A Short Introduction\",\"link\":\"/llm/\"},{\"text\":\"A Very Gentle Introduction to Large Language Models without the Hype\",\"link\":\"/llm/verygentle\"}]}],\"/transformers/\":[{\"text\":\"Transformers\",\"items\":[{\"text\":\"Introdução\",\"link\":\"/transformers/\"}]}],\"/chatbot/\":[{\"text\":\"Chatbot\",\"items\":[{\"text\":\"Sobre\",\"link\":\"/chatbot/\"},{\"text\":\"Como criar um chatbot\",\"link\":\"/chatbot/1-como-criar\"}]}],\"/regressao/\":[{\"text\":\"Regressao Linear\",\"items\":[{\"text\":\"Sobre\",\"link\":\"/regressao/\"},{\"text\":\"Introdução\",\"link\":\"/regressao/1-intro\"},{\"text\":\"Vídeo\",\"link\":\"/regressao/2-video\"},{\"text\":\"Exercício\",\"link\":\"/regressao/3-exercicios\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/giseldo/curdos\"},{\"icon\":\"twitter\",\"link\":\"https://twitter.com/giseldoneo\"},{\"icon\":\"instagram\",\"link\":\"https://instagram.com/neogiseldo\"},{\"icon\":\"youtube\",\"link\":\"https://youtube.com/giseldoneo\"}],\"footer\":{\"message\":\"Todos os direitos reservados.\",\"copyright\":\"© 2025 Giseldo Neo\"},\"search\":{\"provider\":\"local\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>