# M√≥dulos e CommonJS vs. ES Modules

Bem-vindo √† segunda aula do curso **Node.js do B√°sico ao Avan√ßado**! Esta aula foca em um conceito fundamental do Node.js: **m√≥dulos**. Vamos explorar as diferen√ßas entre **CommonJS** e **ES Modules**, os dois sistemas de m√≥dulos dispon√≠veis no Node.js, e como eles s√£o usados para organizar e reutilizar c√≥digo. Al√©m disso, voc√™ aprender√° a criar e importar m√≥dulos personalizados por meio de um exemplo pr√°tico, aplicando boas pr√°ticas e utilizando as vers√µes mais recentes do Node.js (v20.x ou superior, em 2025).

O objetivo √© que voc√™ compreenda as caracter√≠sticas, vantagens e desvantagens de cada sistema de m√≥dulos, al√©m de dominar a cria√ß√£o e importa√ß√£o de m√≥dulos personalizados. O material √© estruturado em duas partes: uma **teoria** detalhada sobre CommonJS e ES Modules, seguida de um **exemplo pr√°tico** que demonstra a implementa√ß√£o em ambos os formatos.

---

## Teoria: Diferen√ßas entre CommonJS e ES Modules

### 1. Introdu√ß√£o aos M√≥dulos no Node.js

M√≥dulos s√£o blocos de c√≥digo reutiliz√°veis que permitem organizar aplica√ß√µes Node.js de forma modular. Eles encapsulam funcionalidades espec√≠ficas, como fun√ß√µes, objetos ou classes, e podem ser importados em outros arquivos para evitar repeti√ß√£o de c√≥digo e melhorar a manutenibilidade. No Node.js, os m√≥dulos s√£o essenciais para estruturar projetos escal√°veis, desde pequenos scripts at√© APIs complexas.

O Node.js suporta dois sistemas de m√≥dulos principais:
- **CommonJS**: O sistema original do Node.js, introduzido em 2009.
- **ES Modules (ESM)**: O padr√£o oficial do JavaScript (ECMAScript), introduzido no ES6 (2015) e totalmente suportado no Node.js a partir da vers√£o 12.

Ambos os sistemas t√™m sintaxes e comportamentos distintos, e entender suas diferen√ßas √© crucial para escolher o mais adequado ao seu projeto e escrever c√≥digo compat√≠vel com as pr√°ticas modernas.

### 2. CommonJS: O Sistema de M√≥dulos Original do Node.js

CommonJS √© o sistema de m√≥dulos nativo do Node.js desde sua cria√ß√£o. Ele foi projetado para permitir modularidade em ambientes JavaScript fora do navegador, onde o ES6 ainda n√£o existia. CommonJS √© amplamente usado em projetos legados e em muitos pacotes npm, embora esteja sendo gradualmente substitu√≠do pelos ES Modules em projetos modernos.

#### 2.1. Caracter√≠sticas do CommonJS

- **Sintaxe**: Usa `require()` para importar m√≥dulos e `module.exports` ou `exports` para export√°-los.
- **Carregamento S√≠ncrono**: M√≥dulos CommonJS s√£o carregados de forma s√≠ncrona, ou seja, o Node.js l√™ e executa o m√≥dulo no momento da importa√ß√£o.
- **Escopo do M√≥dulo**: Cada arquivo √© tratado como um m√≥dulo independente, com seu pr√≥prio escopo. Vari√°veis locais n√£o s√£o acess√≠veis fora do m√≥dulo, a menos que sejam explicitamente exportadas.
- **C√≥pia de Valores**: Quando um m√≥dulo √© importado, o Node.js cria uma c√≥pia dos valores exportados. Altera√ß√µes no m√≥dulo original ap√≥s a importa√ß√£o n√£o afetam a c√≥pia importada (exceto para objetos, que s√£o passados por refer√™ncia).
- **Suporte Nativo**: CommonJS √© suportado em todas as vers√µes do Node.js, sem necessidade de configura√ß√£o adicional.

#### 2.2. Sintaxe do CommonJS

- **Exporta√ß√£o**:
  ```javascript
  // arquivo: math.js
  function soma(a, b) {
    return a + b;
  }
  module.exports = { soma };
  ```
  Ou, alternativamente:
  ```javascript
  exports.soma = function (a, b) {
    return a + b;
  };
  ```

- **Importa√ß√£o**:
  ```javascript
  // arquivo: index.js
  const math = require('./math');
  console.log(math.soma(2, 3)); // 5
  ```

- **Notas**:
  - O caminho `./math` indica um m√≥dulo local no mesmo diret√≥rio. O sufixo `.js` √© opcional.
  - `require()` pode importar m√≥dulos nativos (ex.: `fs`, `http`) ou pacotes npm (ex.: `lodash`).

#### 2.3. Vantagens do CommonJS

- **Simplicidade**: A sintaxe √© direta e f√°cil de entender para iniciantes.
- **Compatibilidade**: Funciona em todas as vers√µes do Node.js e √© amplamente usado em pacotes npm legados.
- **Carregamento Din√¢mico**: Permite importar m√≥dulos condicionalmente ou dinamicamente (ex.: `require(algumaVariavel)`).
- **Suporte em Ferramentas**: Muitas ferramentas de build e bundlers (ex.: Webpack) suportam CommonJS nativamente.

#### 2.4. Desvantagens do CommonJS

- **Carregamento S√≠ncrono**: Pode causar atrasos em aplica√ß√µes grandes, especialmente ao carregar muitos m√≥dulos no in√≠cio.
- **Falta de Tree Shaking**: N√£o suporta tree shaking (remo√ß√£o de c√≥digo morto), o que pode aumentar o tamanho do bundle em aplica√ß√µes frontend.
- **Incompatibilidade com ES Modules**: N√£o pode ser usado diretamente com ES Modules sem ferramentas de convers√£o (ex.: Babel).
- **Sintaxe Menos Moderna**: Comparada aos ES Modules, a sintaxe √© considerada menos elegante e menos alinhada com o JavaScript moderno.

#### 2.5. Como o CommonJS Funciona Internamente

Quando voc√™ usa `require('./math')`, o Node.js segue este processo:
1. **Resolu√ß√£o do M√≥dulo**: O Node.js localiza o arquivo ou pacote com base no caminho fornecido.
2. **Carregamento**: O arquivo √© lido e executado.
3. **Wrapping**: O Node.js envolve o c√≥digo do m√≥dulo em uma fun√ß√£o para criar um escopo isolado:
   ```javascript
   (function (exports, require, module, __filename, __dirname) {
     // C√≥digo do m√≥dulo
   });
   ```
4. **Caching**: O m√≥dulo √© armazenado em cache, garantindo que m√∫ltiplas chamadas a `require()` retornem a mesma inst√¢ncia.
5. **Exporta√ß√£o**: O objeto `module.exports` √© retornado para o c√≥digo que chamou `require()`.

### 3. ES Modules: O Padr√£o Moderno do JavaScript

ES Modules (ESM) √© o sistema de m√≥dulos oficial do ECMAScript, introduzido no ES6 (2015). Ele foi projetado para ser um padr√£o unificado para JavaScript, funcionando tanto no navegador quanto no servidor (Node.js). Desde a vers√£o 12 do Node.js (2019), os ES Modules s√£o suportados nativamente, e em 2025, eles s√£o o padr√£o recomendado para novos projetos devido √† sua integra√ß√£o com o ecossistema JavaScript moderno.

#### 3.1. Caracter√≠sticas dos ES Modules

- **Sintaxe**: Usa `import` para importar e `export` para exportar.
- **Carregamento Ass√≠ncrono**: M√≥dulos ESM s√£o carregados de forma ass√≠ncrona, permitindo melhor performance em aplica√ß√µes modernas.
- **Escopo Estrito**: Funcionam automaticamente em modo estrito (`"use strict"`), garantindo maior seguran√ßa.
- **Suporte a Tree Shaking**: Permite que ferramentas de build (ex.: Rollup, Vite) removam c√≥digo n√£o utilizado, otimizando o tamanho do bundle.
- **Interoperabilidade**: Compat√≠vel com navegadores e ferramentas modernas, facilitando o desenvolvimento full-stack.

#### 3.2. Sintaxe dos ES Modules

- **Exporta√ß√£o**:
  ```javascript
  // arquivo: math.mjs
  export function soma(a, b) {
    return a + b;
  }
  ```
  Ou, exportando m√∫ltiplos itens:
  ```javascript
  export const soma = (a, b) => a + b;
  export const subtracao = (a, b) => a - b;
  ```

- **Importa√ß√£o**:
  ```javascript
  // arquivo: index.mjs
  import { soma } from './math.mjs';
  console.log(soma(2, 3)); // 5
  ```

- **Exporta√ß√£o Padr√£o (Default)**:
  ```javascript
  // arquivo: math.mjs
  export default function soma(a, b) {
    return a + b;
  }
  ```
  ```javascript
  // arquivo: index.mjs
  import soma from './math.mjs';
  console.log(soma(2, 3)); // 5
  ```

- **Notas**:
  - Arquivos ESM usam a extens√£o `.mjs` ou exigem `"type": "module"` no `package.json`.
  - O caminho deve incluir a extens√£o `.mjs` (ou `.js` com configura√ß√£o apropriada).

#### 3.3. Vantagens dos ES Modules

- **Padr√£o Oficial**: Alinhado com o ECMAScript, garantindo compatibilidade com navegadores e Node.js.
- **Carregamento Ass√≠ncrono**: Melhora a performance ao carregar m√≥dulos sob demanda.
- **Tree Shaking**: Reduz o tamanho do c√≥digo em aplica√ß√µes frontend.
- **Sintaxe Moderna**: Mais clara e consistente com o JavaScript moderno (ex.: `import` √© mais intuitivo que `require`).
- **Suporte a Top-Level Await**: Permite usar `await` diretamente no n√≠vel superior do m√≥dulo (ex.: `const data = await fetch(...)`).

#### 3.4. Desvantagens dos ES Modules

- **Configura√ß√£o Adicional**: Em projetos Node.js, √© necess√°rio configurar `"type": "module"` ou usar a extens√£o `.mjs`.
- **Compatibilidade com CommonJS**: Nem todos os pacotes npm s√£o compat√≠veis com ESM, exigindo solu√ß√µes como `import()` din√¢mico ou ferramentas de convers√£o.
- **Curva de Aprendizado**: A sintaxe e as regras (ex.: necessidade de extens√µes nos caminhos) podem confundir iniciantes.
- **Suporte Parcial em Vers√µes Antigas**: Embora irrelevante em 2025, projetos legados em vers√µes antigas do Node.js (pr√©-v12) n√£o suportam ESM nativamente.

#### 3.5. Como os ES Modules Funcionam Internamente

Quando voc√™ usa `import`, o Node.js segue este processo:
1. **Resolu√ß√£o do M√≥dulo**: O Node.js localiza o arquivo com base no caminho, exigindo a extens√£o (ex.: `.mjs`).
2. **Parsing**: O m√≥dulo √© analisado para identificar todas as depend√™ncias (`import` e `export`).
3. **Carregamento Ass√≠ncrono**: As depend√™ncias s√£o carregadas em paralelo, usando promises.
4. **Linkagem**: Os exports s√£o vinculados aos imports, criando refer√™ncias ao vivo (live bindings).
5. **Execu√ß√£o**: O c√≥digo do m√≥dulo √© executado, e os valores exportados ficam dispon√≠veis.

**Live Bindings**: Diferentemente do CommonJS, os ES Modules usam vincula√ß√£o ao vivo. Se o valor exportado mudar no m√≥dulo original, a mudan√ßa √© refletida no m√≥dulo que importou:
```javascript
// arquivo: counter.mjs
export let count = 0;
export function increment() {
  count++;
}
```
```javascript
// arquivo: index.mjs
import { count, increment } from './counter.mjs';
console.log(count); // 0
increment();
console.log(count); // 1
```

### 4. Diferen√ßas Chave entre CommonJS e ES Modules

| Caracter√≠stica                | CommonJS                              | ES Modules                            |
|-------------------------------|---------------------------------------|---------------------------------------|
| **Sintaxe**                   | `require` / `module.exports`          | `import` / `export`                   |
| **Carregamento**              | S√≠ncrono                              | Ass√≠ncrono                            |
| **Extens√£o do Arquivo**       | `.js` (padr√£o)                        | `.mjs` ou `.js` com `"type": "module"`|
| **Escopo**                    | Escopo isolado, mas n√£o estrito       | Modo estrito por padr√£o               |
| **Tree Shaking**              | N√£o suportado                         | Suportado                             |
| **Live Bindings**             | C√≥pia de valores                      | Vincula√ß√£o ao vivo                    |
| **Top-Level Await**           | N√£o suportado                         | Suportado                             |
| **Compatibilidade**           | Ampla (todos os Node.js, pacotes npm) | Nativo desde Node.js 12, mas requer configura√ß√£o |
| **Uso Din√¢mico**              | `require(variavel)`                   | `import()` (importa√ß√£o din√¢mica)      |

#### 4.1. Exemplo de Diferen√ßas Pr√°ticas

**CommonJS**:
```javascript
// math.js
module.exports = {
  soma: (a, b) => a + b
};
```
```javascript
// index.js
const { soma } = require('./math');
console.log(soma(2, 3)); // 5
```

**ES Modules**:
```javascript
// math.mjs
export const soma = (a, b) => a + b;
```
```javascript
// index.mjs
import { soma } from './math.mjs';
console.log(soma(2, 3)); // 5
```

#### 4.2. Configura√ß√£o no Node.js

Para usar ES Modules no Node.js, voc√™ deve:
- Usar a extens√£o `.mjs` para arquivos ESM.
- Ou adicionar `"type": "module"` ao `package.json`:
  ```json
  {
    "name": "meu-projeto",
    "type": "module"
  }
  ```
- Para CommonJS, o padr√£o √© `"type": "commonjs"` (ou aus√™ncia do campo).

#### 4.3. Interoperabilidade

Misturar CommonJS e ES Modules pode ser desafiador:
- **Importar CommonJS em ESM**:
  ```javascript
  import { createRequire } from 'module';
  const require = createRequire(import.meta.url);
  const modulo = require('./modulo.cjs');
  ```
  Ou usar importa√ß√£o din√¢mica:
  ```javascript
  const modulo = await import('./modulo.cjs');
  ```

- **Importar ESM em CommonJS**:
  ```javascript
  const { soma } = await import('./math.mjs');
  ```

Para projetos grandes, ferramentas como **Babel** ou **esbuild** podem converter entre formatos.

### 5. Quando Usar CommonJS vs. ES Modules?

- **Use CommonJS**:
  - Em projetos legados ou pacotes npm que n√£o suportam ESM.
  - Quando a simplicidade e a compatibilidade s√£o prioridades.
  - Em scripts r√°pidos onde a configura√ß√£o extra do ESM n√£o √© necess√°ria.

- **Use ES Modules**:
  - Em projetos novos ou modernos (recomendado em 2025).
  - Quando voc√™ precisa de tree shaking ou integra√ß√£o com navegadores.
  - Para aproveitar recursos como top-level await e sintaxe moderna.
  - Em projetos full-stack onde a consist√™ncia entre frontend e backend √© importante.

Em 2025, **ES Modules** √© o padr√£o recomendado para novos projetos Node.js devido √† sua integra√ß√£o com o ecossistema JavaScript moderno e suporte a ferramentas como Vite, Rollup e TypeScript.

---

## Exemplo Pr√°tico: Criar e Importar um M√≥dulo Personalizado

Neste exemplo pr√°tico, vamos criar um m√≥dulo personalizado para realizar opera√ß√µes matem√°ticas (soma, subtra√ß√£o e multiplica√ß√£o) e import√°-lo em um arquivo principal. Implementaremos o exemplo em **CommonJS** e **ES Modules** para demonstrar as diferen√ßas na pr√°tica.

### Objetivo do Exemplo

- Criar um m√≥dulo personalizado chamado `math` que exporta fun√ß√µes matem√°ticas.
- Importar o m√≥dulo em um arquivo principal (`index.js` ou `index.mjs`) e usar suas fun√ß√µes.
- Testar ambos os formatos (CommonJS e ES Modules) em um projeto Node.js.

### Passo 1: Configurar o Projeto

1. Crie uma nova pasta para o projeto:
   ```bash
   mkdir modulo-personalizado
   cd modulo-personalizado
   npm init -y
   ```

2. O `package.json` ser√° criado com configura√ß√µes padr√£o:
   ```json
   {
     "name": "modulo-personalizado",
     "version": "1.0.0",
     "description": "",
     "main": "index.js",
     "scripts": {
       "test": "echo \"Error: no test specified\" && exit 1"
     },
     "keywords": [],
     "author": "",
     "license": "ISC"
   }
   ```

3. Para ES Modules, modifique o `package.json` (opcional, usado na segunda parte):
   ```json
   {
     "name": "modulo-personalizado",
     "version": "1.0.0",
     "type": "module",
     "main": "index.js",
     "scripts": {
       "test": "echo \"Error: no test specified\" && exit 1"
     },
     "keywords": [],
     "author": "",
     "license": "ISC"
   }
   ```

4. Instale o `nodemon` para reiniciar o servidor automaticamente (opcional):
   ```bash
   npm install --save-dev nodemon
   ```
   Adicione ao `package.json`:
   ```json
   "scripts": {
     "start": "node index.js",
     "dev": "nodemon index.js"
   }
   ```

### Passo 2: Implementa√ß√£o com CommonJS

1. **Criar o M√≥dulo Personalizado**:
   Crie um arquivo `math.js`:
   ```javascript
   // math.js
   function soma(a, b) {
     return a + b;
   }

   function subtracao(a, b) {
     return a - b;
   }

   function multiplicacao(a, b) {
     return a * b;
   }

   module.exports = {
     soma,
     subtracao,
     multiplicacao
   };
   ```

2. **Importar e Usar o M√≥dulo**:
   Crie um arquivo `index.js`:
   ```javascript
   // index.js
   const math = require('./math');

   console.log('Soma: ', math.soma(5, 3)); // Soma: 8
   console.log('Subtra√ß√£o: ', math.subtracao(5, 3)); // Subtra√ß√£o: 2
   console.log('Multiplica√ß√£o: ', math.multiplicacao(5, 3)); // Multiplica√ß√£o: 15
   ```

3. **Executar o Projeto**:
   ```bash
   node index.js
   ```
   Ou, com nodemon:
   ```bash
   npm run dev
   ```

   **Sa√≠da esperada**:
   ```
   Soma: 8
   Subtra√ß√£o: 2
   Multiplica√ß√£o: 15
   ```

4. **Explica√ß√£o**:
   - O m√≥dulo `math.js` exporta um objeto contendo tr√™s fun√ß√µes usando `module.exports`.
   - O `index.js` importa o m√≥dulo com `require` e acessa as fun√ß√µes via `math.soma`, `math.subtracao`, etc.
   - O carregamento √© s√≠ncrono, e o Node.js armazena o m√≥dulo em cache ap√≥s a primeira importa√ß√£o.

### Passo 3: Implementa√ß√£o com ES Modules

1. **Atualizar o package.json**:
   Certifique-se de que o `package.json` inclui:
   ```json
   "type": "module"
   ```

2. **Criar o M√≥dulo Personalizado**:
   Crie um arquivo `math.mjs`:
   ```javascript
   // math.mjs
   export function soma(a, b) {
     return a + b;
   }

   export function subtracao(a, b) {
     return a - b;
   }

   export function multiplicacao(a, b) {
     return a * b;
   }

   // Exporta√ß√£o padr√£o (opcional)
   export default {
     soma,
     subtracao,
     multiplicacao
   };
   ```

3. **Importar e Usar o M√≥dulo**:
   Crie um arquivo `index.mjs`:
   ```javascript
   // index.mjs
   import { soma, subtracao, multiplicacao } from './math.mjs';
   // Ou, usando importa√ß√£o padr√£o:
   // import math from './math.mjs';

   console.log('Soma: ', soma(5, 3)); // Soma: 8
   console.log('Subtra√ß√£o: ', subtracao(5, 3)); // Subtra√ß√£o: 2
   console.log('Multiplica√ß√£o: ', multiplicacao(5, 3)); // Multiplica√ß√£o: 15
   ```

4. **Executar o Projeto**:
   ```bash
   node index.mjs
   ```
   Ou, com nodemon:
   ```bash
   npm run dev
   ```

   **Sa√≠da esperada**:
   ```
   Soma: 8
   Subtra√ß√£o: 2
   Multiplica√ß√£o: 15
   ```

5. **Explica√ß√£o**:
   - O m√≥dulo `math.mjs` usa `export` para exportar fun√ß√µes individualmente e, opcionalmente, um objeto padr√£o com `export default`.
   - O `index.mjs` importa as fun√ß√µes com `import`, especificando o caminho com a extens√£o `.mjs`.
   - O carregamento √© ass√≠ncrono, e os ES Modules suportam live bindings, permitindo que altera√ß√µes no m√≥dulo original sejam refletidas.

### Passo 4: Testando Diferen√ßas com Live Bindings

Para demonstrar os **live bindings** dos ES Modules, vamos criar um exemplo que mostra a diferen√ßa em rela√ß√£o ao CommonJS.

1. **CommonJS (C√≥pia de Valores)**:
   ```javascript
   // counter.js
   let count = 0;

   function increment() {
     count++;
     console.log('Count no m√≥dulo:', count);
   }

   module.exports = { count, increment };
   ```
   ```javascript
   // index.js
   const { count, increment } = require('./counter');
   console.log('Count inicial:', count); // 0
   increment();
   console.log('Count ap√≥s increment:', count); // 0 (n√£o reflete a mudan√ßa)
   ```

2. **ES Modules (Live Bindings)**:
   ```javascript
   // counter.mjs
   export let count = 0;

   export function increment() {
     count++;
     console.log('Count no m√≥dulo:', count);
   }
   ```
   ```javascript
   // index.mjs
   import { count, increment } from './counter.mjs';
   console.log('Count inicial:', count); // 0
   increment();
   console.log('Count ap√≥s increment:', count); // 1 (reflete a mudan√ßa)
   ```

3. **Executar**:
   - Para CommonJS: `node index.js`
   - Para ES Modules: `node index.mjs`

   **Sa√≠da do CommonJS**:
   ```
   Count inicial: 0
   Count no m√≥dulo: 1
   Count ap√≥s increment: 0
   ```

   **Sa√≠da do ES Modules**:
   ```
   Count inicial: 0
   Count no m√≥dulo: 1
   Count ap√≥s increment: 1
   ```

4. **Explica√ß√£o**:
   - No CommonJS, `count` √© uma c√≥pia do valor exportado, ent√£o mudan√ßas no m√≥dulo original n√£o afetam o valor importado.
   - Nos ES Modules, `count` √© uma refer√™ncia ao vivo, refletindo mudan√ßas no m√≥dulo original.

### Passo 5: Boas Pr√°ticas

1. **Organize M√≥dulos**:
   - Crie uma pasta `lib` ou `utils` para m√≥dulos reutiliz√°veis.
   - Nomeie arquivos de forma descritiva (ex.: `mathOperations.js`).

2. **Use ES Modules em Projetos Novos**:
   - Configure `"type": "module"` no `package.json` para consist√™ncia.
   - Prefira `.js` com ESM em vez de `.mjs` para evitar extens√µes espec√≠ficas.

3. **Evite Misturar Formatos**:
   - Escolha um sistema (CommonJS ou ESM) para todo o projeto para evitar problemas de interoperabilidade.
   - Use `import()` din√¢mico para casos excepcionais.

4. **Versionamento**:
   - Adicione os arquivos ao Git:
     ```bash
     git init
     git add .
     git commit -m "M√≥dulo personalizado com CommonJS e ES Modules"
     ```

5. **Depura√ß√£o**:
   - Use o VS Code para depurar:
     - Adicione breakpoints nos arquivos `index.js` ou `index.mjs`.
     - Configure o `launch.json` para ESM, se necess√°rio:
       ```json
       {
         "version": "0.2.0",
         "configurations": [
           {
             "type": "node",
             "request": "launch",
             "name": "Launch ESM",
             "program": "${workspaceFolder}/index.mjs"
           }
         ]
       }
       ```

---

## Conclus√£o

Nesta aula, voc√™ aprendeu:
- **CommonJS**: Sistema de m√≥dulos s√≠ncrono, usando `require` e `module.exports`, ideal para projetos legados.
- **ES Modules**: Padr√£o moderno, ass√≠ncrono, com `import` e `export`, recomendado para projetos novos em 2025.
- **Diferen√ßas**: Carregamento, sintaxe, live bindings, tree shaking e interoperabilidade.
- **Exemplo Pr√°tico**: Criou um m√≥dulo personalizado (`math`) e o importou em ambos os formatos, testando diferen√ßas como live bindings.

Este conhecimento √© fundamental para organizar projetos Node.js de forma modular e escal√°vel. Nos pr√≥ximos m√≥dulos, voc√™ aplicar√° esses conceitos para construir APIs, manipular arquivos e integrar bancos de dados.

### Pr√≥ximos Passos

- Experimente criar novos m√≥dulos personalizados (ex.: um m√≥dulo para strings ou c√°lculos avan√ßados).
- Explore a documenta√ß√£o de m√≥dulos no Node.js: [nodejs.org/api/modules.html](https://nodejs.org/api/modules.html).
- Prepare-se para o pr√≥ximo m√≥dulo, onde abordaremos o **Sistema de Arquivos (fs module)**.

Se tiver d√∫vidas ou quiser mais exemplos, √© s√≥ pedir! üöÄ
